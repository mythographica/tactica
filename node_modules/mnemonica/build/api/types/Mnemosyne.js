'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("../../constants");
const { odp, SymbolConstructorName, MNEMONICA, } = constants_1.constants;
const utils_1 = require("../utils");
const { getTypeChecker, findSubTypeFromParent, reflectPrimitiveWrappers } = utils_1.default;
const extract_1 = require("../../utils/extract");
const parent_1 = require("../../utils/parent");
const pick_1 = require("../../utils/pick");
const exceptionConstructor_1 = require("../errors/exceptionConstructor");
const InstanceCreator_1 = require("./InstanceCreator");
const Props_1 = require("./Props");
const getDefaultPrototype = () => {
    return Object.create(null);
};
const MnemonicaProtoProps = {
    extract() {
        return function () {
            return (0, extract_1.extract)(this);
        };
    },
    pick() {
        return function (...args) {
            return (0, pick_1.pick)(this, ...args);
        };
    },
    parent() {
        return function (constructorLookupPath) {
            return (0, parent_1.parent)(this, constructorLookupPath);
        };
    },
    clone() {
        return this.fork();
    },
    fork() {
        const props = (0, Props_1._getProps)(this);
        const { __type__: type, __collection__: collection, __parent__: existentInstance, __args__, __self__, } = props;
        const { isSubType, TypeName } = type;
        return function (...forkArgs) {
            let forked;
            const Constructor = isSubType ?
                existentInstance :
                collection;
            const args = forkArgs.length ? forkArgs : __args__;
            if (this === __self__) {
                forked = new (Constructor[TypeName])(...args);
            }
            else {
                forked = new InstanceCreator_1.InstanceCreator(type, reflectPrimitiveWrappers(this), args);
            }
            return forked;
        };
    },
    [SymbolConstructorName]() {
        return MNEMONICA;
    },
    exception() {
        const self = this;
        return function (error, ...args) {
            const target = new.target;
            return exceptionConstructor_1.default.call(self, target, error, ...args);
        };
    },
    sibling() {
        const siblings = (SiblingTypeName) => {
            const props = (0, Props_1._getProps)(this);
            const { __collection__: collection, } = props;
            const sibling = collection[SiblingTypeName];
            return sibling;
        };
        return new Proxy(siblings, {
            get(_, prop) {
                return siblings(prop);
            },
            apply(_, __, args) {
                return siblings(args[0]);
            }
        });
    }
};
const staticProps = [
    'constructor',
    'prototype',
    'then',
    'stack',
    'message',
    'domain',
    'on',
    'once',
    'off',
    'inspect',
    'showDiff',
]
    .concat(Object.keys(MnemonicaProtoProps))
    .concat(Object.getOwnPropertyNames(Object.prototype))
    .concat(Object.getOwnPropertyNames(Function.prototype))
    .reduce((obj, key) => {
    obj[key] = true;
    return obj;
}, Object.create(null));
const makeSubTypeProxy = function (subtype, inheritedInstance) {
    const subtypeProxy = new Proxy(InstanceCreator_1.InstanceCreator, {
        get(Target, _prop) {
            if (_prop === Symbol.hasInstance) {
                return getTypeChecker(subtype.TypeName);
            }
            return Reflect.get(Target, _prop);
        },
        construct(Target, _args) {
            return new Target(subtype, inheritedInstance, _args);
        },
        apply(Target, thisArg, _args) {
            if (thisArg === undefined) {
                thisArg = inheritedInstance;
            }
            const existentInstance = reflectPrimitiveWrappers(thisArg);
            const entity = new Target(subtype, existentInstance, _args);
            return entity;
        },
    });
    return subtypeProxy;
};
const prepareSubtypeForConstruction = function (subtypeName, inheritedInstance) {
    const propInstance = Reflect.getPrototypeOf(inheritedInstance);
    const props = (0, Props_1._getProps)(propInstance);
    if (!props) {
        return undefined;
    }
    const { __type__: { config: { strictChain }, subtypes }, } = props;
    const subtype = subtypes.has(subtypeName) ?
        subtypes.get(subtypeName) :
        strictChain ?
            undefined :
            findSubTypeFromParent(inheritedInstance, subtypeName);
    return subtype ? makeSubTypeProxy(subtype, inheritedInstance) : undefined;
};
const mnemosyneProxyHandlerGet = (target, prop, receiver) => {
    const result = Reflect.get(target, prop, receiver);
    if (result !== undefined) {
        return result;
    }
    if (typeof prop === 'symbol') {
        return result;
    }
    if (staticProps[prop]) {
        return result;
    }
    const subtype = prepareSubtypeForConstruction(prop, receiver);
    return subtype || result;
};
const Mnemosyne = function (mnemonica) {
    const instance = this;
    const Mnemonica = function () {
        odp(this, SymbolConstructorName, {
            get() {
                return MNEMONICA;
            }
        });
    };
    Object.setPrototypeOf(Mnemonica.prototype, mnemonica);
    Object.entries(MnemonicaProtoProps).forEach(([name, method]) => {
        odp(Mnemonica.prototype, name, {
            get() {
                return method.call(this);
            }
        });
    });
    Object.getOwnPropertySymbols(MnemonicaProtoProps).forEach((symbol) => {
        odp(Mnemonica.prototype, symbol, {
            get() {
                const symbolMethod = Reflect.get(MnemonicaProtoProps, symbol);
                return symbolMethod.call(this);
            }
        });
    });
    odp(Mnemonica.prototype, Symbol.hasInstance, {
        get() {
            return getTypeChecker(this.constructor.name);
        }
    });
    const proto = new Mnemonica();
    Reflect.setPrototypeOf(instance, proto);
};
const createMnemosyne = function (Uranus) {
    const uranus = reflectPrimitiveWrappers(Uranus);
    const mnemosyne = new Mnemosyne(uranus);
    const mnemosyneProxy = new Proxy(mnemosyne, {
        get: mnemosyneProxyHandlerGet
    });
    return mnemosyneProxy;
};
exports.default = {
    get createMnemosyne() {
        return createMnemosyne;
    },
    get prepareSubtypeForConstruction() {
        return prepareSubtypeForConstruction;
    },
    get getDefaultPrototype() {
        return getDefaultPrototype;
    },
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTW5lbW9zeW5lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2FwaS90eXBlcy9NbmVtb3N5bmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxDQUFDOztBQUdiLCtDQUE0QztBQUM1QyxNQUFNLEVBQ0wsR0FBRyxFQUNILHFCQUFxQixFQUVyQixTQUFTLEdBRVQsR0FBRyxxQkFBUyxDQUFDO0FBRWQsb0NBQWtDO0FBQ2xDLE1BQU0sRUFDTCxjQUFjLEVBQ2QscUJBQXFCLEVBQ3JCLHdCQUF3QixFQUN4QixHQUFHLGVBQVUsQ0FBQztBQUVmLGlEQUE4QztBQUM5QywrQ0FBNEM7QUFDNUMsMkNBQXdDO0FBRXhDLHlFQUFrRTtBQUVsRSx1REFBb0Q7QUFFcEQsbUNBQTJDO0FBRTNDLE1BQU0sbUJBQW1CLEdBQUcsR0FBRyxFQUFFO0lBQ2hDLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUM1QixDQUFDLENBQUM7QUFJRixNQUFNLG1CQUFtQixHQUFHO0lBRTNCLE9BQU87UUFDTixPQUFPO1lBQ04sT0FBTyxJQUFBLGlCQUFPLEVBQUMsSUFBSSxDQUFDLENBQUM7UUFDdEIsQ0FBQyxDQUFDO0lBQ0gsQ0FBQztJQUVELElBQUk7UUFDSCxPQUFPLFVBQXdCLEdBQUcsSUFBMkI7WUFDNUQsT0FBTyxJQUFBLFdBQUksRUFBQyxJQUFJLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUM1QixDQUFDLENBQUM7SUFDSCxDQUFDO0lBRUQsTUFBTTtRQUNMLE9BQU8sVUFBd0IscUJBQTZCO1lBQzNELE9BQU8sSUFBQSxlQUFNLEVBQUMsSUFBSSxFQUFFLHFCQUFxQixDQUFDLENBQUM7UUFDNUMsQ0FBQyxDQUFDO0lBQ0gsQ0FBQztJQUVELEtBQUs7UUFDSixPQUFPLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUNwQixDQUFDO0lBRUQsSUFBSTtRQUVILE1BQU0sS0FBSyxHQUFHLElBQUEs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LENBQUMsU0FBUyxFQUFFLE1BQU0sQ0FBQyxXQUFXLEVBQUU7UUFDNUMsR0FBRztZQUNGLE9BQU8sY0FBYyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDOUMsQ0FBQztLQUNELENBQUMsQ0FBQztJQUVILE1BQU0sS0FBSyxHQUFHLElBQUksU0FBUyxFQUFFLENBQUM7SUFDOUIsT0FBTyxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFJekMsQ0FBb0QsQ0FBQztBQUVyRCxNQUFNLGVBQWUsR0FBRyxVQUFVLE1BQWU7SUFVaEQsTUFBTSxNQUFNLEdBQUcsd0JBQXdCLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDaEQsTUFBTSxTQUFTLEdBQUcsSUFBSSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDeEMsTUFBTSxjQUFjLEdBQUcsSUFBSSxLQUFLLENBQUMsU0FBUyxFQUFFO1FBQzNDLEdBQUcsRUFBRyx3QkFBd0I7S0FDOUIsQ0FBQyxDQUFDO0lBRUgsT0FBTyxjQUFjLENBQUM7QUFDdkIsQ0FBQyxDQUFDO0FBRUYsa0JBQWU7SUFDZCxJQUFJLGVBQWU7UUFDbEIsT0FBTyxlQUFlLENBQUM7SUFDeEIsQ0FBQztJQUNELElBQUksNkJBQTZCO1FBQ2hDLE9BQU8sNkJBQTZCLENBQUM7SUFDdEMsQ0FBQztJQUNELElBQUksbUJBQW1CO1FBQ3RCLE9BQU8sbUJBQW1CLENBQUM7SUFDNUIsQ0FBQztDQU9ELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IENvbnN0cnVjdG9yRnVuY3Rpb24gfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBjb25zdGFudHMgfSBmcm9tICcuLi8uLi9jb25zdGFudHMnO1xuY29uc3Qge1xuXHRvZHAsXG5cdFN5bWJvbENvbnN0cnVjdG9yTmFtZSxcblxuXHRNTkVNT05JQ0EsXG5cbn0gPSBjb25zdGFudHM7XG5cbmltcG9ydCBUeXBlc1V0aWxzIGZyb20gJy4uL3V0aWxzJztcbmNvbnN0IHtcblx0Z2V0VHlwZUNoZWNrZXIsXG5cdGZpbmRTdWJUeXBlRnJvbVBhcmVudCxcblx0cmVmbGVjdFByaW1pdGl2ZVdyYXBwZXJzXG59ID0gVHlwZXNVdGlscztcblxuaW1wb3J0IHsgZXh0cmFjdCB9IGZyb20gJy4uLy4uL3V0aWxzL2V4dHJhY3QnO1xuaW1wb3J0IHsgcGFyZW50IH0gZnJvbSAnLi4vLi4vdXRpbHMvcGFyZW50JztcbmltcG9ydCB7IHBpY2sgfSBmcm9tICcuLi8uLi91dGlscy9waWNrJztcblxuaW1wb3J0IGV4Y2VwdGlvbkNvbnN0cnVjdG9yIGZyb20gJy4uL2Vycm9ycy9leGNlcHRpb25Db25zdHJ1Y3Rvcic7XG5cbmltcG9ydCB7IEluc3RhbmNlQ3JlYXRvciB9IGZyb20gJy4vSW5zdGFuY2VDcmVhdG9yJztcblxuaW1wb3J0IHsgX2dldFByb3BzLCBQcm9wcyB9IGZyb20gJy4vUHJvcHMnO1xuXG5jb25zdCBnZXREZWZhdWx0UHJvdG90eXBlID0gKCkgPT4ge1xuXHRyZXR1cm4gT2JqZWN0LmNyZWF0ZShudWxsKTtcbn07XG5cbi8vIGNvbnN0IEluc3RhbmNlUm9vdHMgPSBuZXcgV2Vha01hcDtcblxuY29uc3QgTW5lbW9uaWNhUHJvdG9Qcm9wcyA9IHtcblxuXHRleHRyYWN0ICgpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHRoaXM6IG9iamVjdCkge1xuXHRcdFx0cmV0dXJuIGV4dHJhY3QodGhpcyk7XG5cdFx0fTtcblx0fSxcblxuXHRwaWNrICgpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHRoaXM6IG9iamVjdCwgLi4uYXJnczogKHN0cmluZyB8IHN0cmluZ1tdKVtdKSB7XG5cdFx0XHRyZXR1cm4gcGljayh0aGlzLCAuLi5hcmdzKTtcblx0XHR9O1xuXHR9LFxuXG5cdHBhcmVudCAoKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICh0aGlzOiBvYmplY3QsIGNvbnN0cnVjdG9yTG9va3VwUGF0aDogc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcGFyZW50KHRoaXMsIGNvbnN0cnVjdG9yTG9va3VwUGF0aCk7XG5cdFx0fTtcblx0fSxcblxuXHRjbG9uZSAodGhpczogeyBmb3JrOiAoKSA9PiBvYmplY3QgfSkge1xuXHRcdHJldHVybiB0aGlzLmZvcmsoKTtcblx0fSxcblxuXHRmb3JrICh0aGlzOiBvYmplY3QpIHtcblxuXHRcdGNvbnN0IHByb3BzID0gX2dldFByb3BzKHRoaXMpIGFzIFByb3BzO1xuXG5cdFx0Y29uc3Qge1xuXHRcdFx0X190eXBlX186IHR5cGUsXG5cdFx0XHRfX2NvbGxlY3Rpb25fXzogY29sbGVjdGlvbixcblx0XHRcdF9fcGFyZW50X186IGV4aXN0ZW50SW5zdGFuY2UsXG5cdFx0XHRfX2FyZ3NfXyxcblx0XHRcdF9fc2VsZl9fLFxuXHRcdH0gPSBwcm9wcztcblxuXHRcdGNvbnN0IHtcblx0XHRcdGlzU3ViVHlwZSxcblx0XHRcdFR5cGVOYW1lXG5cdFx0fSA9IHR5cGU7XG5cblx0XHQvLyAnZnVuY3Rpb24nLCBjYXVzZSBtaWdodCBiZSBjYWxsZWQgd2l0aCAnbmV3J1xuXHRcdCBcblx0XHRyZXR1cm4gZnVuY3Rpb24gKHRoaXM6IG9iamVjdCwgLi4uZm9ya0FyZ3M6IHVua25vd25bXSkge1xuXG5cdFx0XHRsZXQgZm9ya2VkO1xuXHRcdFx0Y29uc3QgQ29uc3RydWN0b3IgPSBpc1N1YlR5cGUgP1xuXHRcdFx0XHRleGlzdGVudEluc3RhbmNlIDpcblx0XHRcdFx0Y29sbGVjdGlvbjtcblxuXHRcdFx0Y29uc3QgYXJncyA9IGZvcmtBcmdzLmxlbmd0aCA/IGZvcmtBcmdzIDogX19hcmdzX187XG5cblxuXHRcdFx0aWYgKHRoaXMgPT09IF9fc2VsZl9fKSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcblx0XHRcdFx0Ly8gQHRzLWV4cGVjdC1lcnJvciBcblx0XHRcdFx0Zm9ya2VkID0gbmV3IChDb25zdHJ1Y3RvclsgVHlwZU5hbWUgXSkoLi4uYXJncyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBmb3JrLmNhbGwgPyBsZXQncyBkbyBpdCAhXG5cdFx0XHRcdGZvcmtlZCA9IG5ldyBJbnN0YW5jZUNyZWF0b3IodHlwZSwgcmVmbGVjdFByaW1pdGl2ZVdyYXBwZXJzKHRoaXMpLCBhcmdzKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGZvcmtlZDtcblxuXHRcdH07XG5cdH0sXG5cblx0WyBTeW1ib2xDb25zdHJ1Y3Rvck5hbWUgXSAoKSB7XG5cdFx0cmV0dXJuIE1ORU1PTklDQTtcblx0fSxcblxuXHRleGNlcHRpb24gKCkge1xuXHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuXHRcdGNvbnN0IHNlbGYgPSB0aGlzO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoZXJyb3I6IEVycm9yLCAuLi5hcmdzOiB1bmtub3duW10pIHtcblx0XHRcdGNvbnN0IHRhcmdldCA9IG5ldy50YXJnZXQ7XG5cdFx0XHRyZXR1cm4gZXhjZXB0aW9uQ29uc3RydWN0b3IuY2FsbChzZWxmLCB0YXJnZXQsIGVycm9yLCAuLi5hcmdzKTtcblx0XHR9O1xuXHR9LFxuXG5cdHNpYmxpbmcgKCkge1xuXHRcdCBcblx0XHRjb25zdCBzaWJsaW5ncyA9IChTaWJsaW5nVHlwZU5hbWU6IHN0cmluZykgPT4ge1xuXG5cdFx0XHRjb25zdCBwcm9wcyA9IF9nZXRQcm9wcyh0aGlzKSBhcyBQcm9wcztcblx0XHRcdGNvbnN0IHtcblx0XHRcdFx0X19jb2xsZWN0aW9uX186IGNvbGxlY3Rpb24sXG5cdFx0XHR9ID0gcHJvcHM7XG5cdFx0XHRjb25zdCBzaWJsaW5nOiB1bmtub3duID0gY29sbGVjdGlvblsgU2libGluZ1R5cGVOYW1lIF07XG5cdFx0XHRyZXR1cm4gc2libGluZztcblx0XHR9O1xuXG5cdFx0cmV0dXJuIG5ldyBQcm94eShzaWJsaW5ncywge1xuXHRcdFx0Z2V0IChfLCBwcm9wOiBzdHJpbmcpIHtcblx0XHRcdFx0cmV0dXJuIHNpYmxpbmdzKHByb3ApO1xuXHRcdFx0fSxcblx0XHRcdGFwcGx5IChfLCBfXywgYXJncywpIHtcblx0XHRcdFx0cmV0dXJuIHNpYmxpbmdzKGFyZ3NbIDAgXSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH1cblxufTtcblxuY29uc3Qgc3RhdGljUHJvcHMgPSBbXG5cblx0Ly8gYnVpbHRpbnM6IGZ1bmN0aW9ucyArIFByb21pc2VzXG5cdCdjb25zdHJ1Y3RvcicsXG5cdCdwcm90b3R5cGUnLFxuXHQndGhlbicsXG5cblx0Ly8gYnVpbHRpbnM6IGVycm9yc1xuXHQnc3RhY2snLFxuXHQnbWVzc2FnZScsXG5cdCdkb21haW4nLFxuXG5cdC8vIGJ1aWx0aW5zOiBFdmVudEVtaXR0ZXJcblx0J29uJyxcblx0J29uY2UnLFxuXHQnb2ZmJyxcblxuXHQvLyBtb2NoYSArIGNoYWkgPT4gYnVnOiAuL3V0aWxzLmpzIC5maW5kU3ViVHlwZUZyb21QYXJlbnQgJ2luc3BlY3QnXG5cdCdpbnNwZWN0Jyxcblx0J3Nob3dEaWZmJyxcblxuXVxuXHQuY29uY2F0KE9iamVjdC5rZXlzKE1uZW1vbmljYVByb3RvUHJvcHMpKVxuXHQuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKE9iamVjdC5wcm90b3R5cGUpKVxuXHQuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKEZ1bmN0aW9uLnByb3RvdHlwZSkpXG5cdC5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG5cdFx0b2JqWyBrZXkgXSA9IHRydWU7XG5cdFx0cmV0dXJuIG9iajtcblx0fSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG5cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogb25seS1hcnJvdy1mdW5jdGlvbnNcbmNvbnN0IG1ha2VTdWJUeXBlUHJveHkgPSBmdW5jdGlvbiAoc3VidHlwZTogYW55LCBpbmhlcml0ZWRJbnN0YW5jZTogdW5rbm93bikge1xuXG5cdGNvbnN0IHN1YnR5cGVQcm94eSA9IG5ldyBQcm94eShJbnN0YW5jZUNyZWF0b3IsIHtcblxuXHRcdGdldCAoVGFyZ2V0LCBfcHJvcCkge1xuXG5cdFx0XHRpZiAoX3Byb3AgPT09IFN5bWJvbC5oYXNJbnN0YW5jZSkge1xuXHRcdFx0XHRyZXR1cm4gZ2V0VHlwZUNoZWNrZXIoc3VidHlwZS5UeXBlTmFtZSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBSZWZsZWN0LmdldChUYXJnZXQsIF9wcm9wKTtcblxuXHRcdH0sXG5cblx0XHRjb25zdHJ1Y3QgKFRhcmdldCwgX2FyZ3MpIHtcblx0XHRcdHJldHVybiBuZXcgVGFyZ2V0KHN1YnR5cGUsIGluaGVyaXRlZEluc3RhbmNlLCBfYXJncyk7XG5cdFx0fSxcblxuXHRcdGFwcGx5IChUYXJnZXQsIHRoaXNBcmcsIF9hcmdzKSB7XG5cblx0XHRcdGlmICh0aGlzQXJnID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpc0FyZyA9IGluaGVyaXRlZEluc3RhbmNlO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBleGlzdGVudEluc3RhbmNlID0gcmVmbGVjdFByaW1pdGl2ZVdyYXBwZXJzKHRoaXNBcmcpO1xuXG5cdFx0XHRjb25zdCBlbnRpdHkgPSBuZXcgVGFyZ2V0KHN1YnR5cGUsIGV4aXN0ZW50SW5zdGFuY2UsIF9hcmdzKTtcblx0XHRcdHJldHVybiBlbnRpdHk7XG5cdFx0fSxcblxuXHR9KTtcblxuXHRyZXR1cm4gc3VidHlwZVByb3h5O1xufTtcblxuY29uc3QgcHJlcGFyZVN1YnR5cGVGb3JDb25zdHJ1Y3Rpb24gPSBmdW5jdGlvbiAoc3VidHlwZU5hbWU6IHN0cmluZywgaW5oZXJpdGVkSW5zdGFuY2U6IHVua25vd24pIHtcblx0Ly8gcHJvdG90eXBlIG9mIHByb3h5XG5cdGNvbnN0IHByb3BJbnN0YW5jZSA9IFJlZmxlY3QuZ2V0UHJvdG90eXBlT2YoaW5oZXJpdGVkSW5zdGFuY2UgYXMgb2JqZWN0KSBhcyBvYmplY3Q7XG5cblx0Y29uc3QgcHJvcHMgPSBfZ2V0UHJvcHMocHJvcEluc3RhbmNlKSBhcyBQcm9wcztcblx0aWYgKCFwcm9wcykge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHRjb25zdCB7XG5cdFx0X190eXBlX186IHtcblx0XHRcdGNvbmZpZzoge1xuXHRcdFx0XHRzdHJpY3RDaGFpblxuXHRcdFx0fSxcblx0XHRcdHN1YnR5cGVzXG5cdFx0fSxcblx0fSA9IHByb3BzO1xuXG5cblx0Y29uc3Qgc3VidHlwZSA9IHN1YnR5cGVzLmhhcyhzdWJ0eXBlTmFtZSkgP1xuXHRcdHN1YnR5cGVzLmdldChzdWJ0eXBlTmFtZSkgOlxuXHRcdHN0cmljdENoYWluID9cblx0XHRcdHVuZGVmaW5lZCA6XG5cdFx0XHRmaW5kU3ViVHlwZUZyb21QYXJlbnQoaW5oZXJpdGVkSW5zdGFuY2UgYXMgb2JqZWN0LCBzdWJ0eXBlTmFtZSk7XG5cblx0cmV0dXJuIHN1YnR5cGUgPyBtYWtlU3ViVHlwZVByb3h5KHN1YnR5cGUsIGluaGVyaXRlZEluc3RhbmNlKSA6IHVuZGVmaW5lZDtcbn07XG5cbmNvbnN0IG1uZW1vc3luZVByb3h5SGFuZGxlckdldCA9ICh0YXJnZXQ6IG9iamVjdCwgcHJvcDogc3RyaW5nLCByZWNlaXZlcjogdW5rbm93bikgPT4ge1xuXG5cdC8vIE5vZGUuanMgMjIgUmVmbGVjdC5nZXQgQmVoYXZpb3VyIENoYW5nZWQgaGVyZVxuXHQvLyBjYXVzZSBzb21ldGhpbmcgZ29uZSB3cm9uZyB3aXRoIHByb3AgYXNzaWdubWVudFxuXHQvLyBzbyBub3cgaWYgd2UgbmVlZCAuc3RhY2ssIHdlIHNob3VsZCBhdm9pZCByZWNlaXZlciBoZXJlXG5cdC8vIG5hdmUgbm90IHlldCBjaGVja2VkIG90aGVyIHN0YXRpY1Byb3BzLFxuXHQvLyBqdXN0IGZpeGVkIHRoaXMgYmVsb3dcblx0Ly8gd2hpbGUgdXNpbmcgY29uZGl0aW9uYWwgZm9yIHN0YXRpY1Byb3BzXG5cdGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuXG5cdGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRpZiAodHlwZW9mIHByb3AgPT09ICdzeW1ib2wnKSB7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGlmIChzdGF0aWNQcm9wc1sgcHJvcCBdKSB7XG5cdFx0Lypcblx0XHRjb25zdCBtYXlCZVJlc3VsdCA9IFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCk7XG5cdFx0aWYgKG1heUJlUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiBtYXlCZVJlc3VsdDtcblx0XHR9XG5cdFx0Ki9cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0Y29uc3Qgc3VidHlwZSA9IHByZXBhcmVTdWJ0eXBlRm9yQ29uc3RydWN0aW9uKHByb3AsIHJlY2VpdmVyKTtcblx0cmV0dXJuIHN1YnR5cGUgfHwgcmVzdWx0O1xufTtcblxuY29uc3QgTW5lbW9zeW5lID0gZnVuY3Rpb24gKG1uZW1vbmljYTogb2JqZWN0KSB7XG5cblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG5cdGNvbnN0IGluc3RhbmNlID0gdGhpcztcblxuXHRjb25zdCBNbmVtb25pY2EgPSBmdW5jdGlvbiAodGhpczogb2JqZWN0KSB7XG5cdFx0b2RwKHRoaXMsIFN5bWJvbENvbnN0cnVjdG9yTmFtZSwge1xuXHRcdFx0Z2V0ICgpIHtcblx0XHRcdFx0cmV0dXJuIE1ORU1PTklDQTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSBhcyBDb25zdHJ1Y3RvckZ1bmN0aW9uPHR5cGVvZiBNbmVtb25pY2FQcm90b1Byb3BzPjtcblx0XG5cdC8vIHRoaXMgdGhyb3dzIGFuIGVycm9yXG5cdE9iamVjdC5zZXRQcm90b3R5cGVPZihNbmVtb25pY2EucHJvdG90eXBlLCBtbmVtb25pY2EpO1xuXHQvLyB3aGlsZSB0aGlzIGp1c3QgcmV0dXJucyBmYWxzZSwgc2lsZW50bHkgLi4uIHVuZm9ydHVuYXRlbHlcblx0Ly8gUmVmbGVjdC5zZXRQcm90b3R5cGVPZihNbmVtb25pY2EucHJvdG90eXBlLCBtbmVtb25pY2EpO1xuXG5cdE9iamVjdC5lbnRyaWVzKE1uZW1vbmljYVByb3RvUHJvcHMpLmZvckVhY2goKFsgbmFtZSwgbWV0aG9kIF06IFtzdHJpbmcsIHVua25vd25dKSA9PiB7XG5cdFx0b2RwKE1uZW1vbmljYS5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGdldCAoKSB7XG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZVxuXHRcdFx0XHRyZXR1cm4gKG1ldGhvZCBhcyBDYWxsYWJsZUZ1bmN0aW9uKS5jYWxsKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblxuXHRPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKE1uZW1vbmljYVByb3RvUHJvcHMpLmZvckVhY2goKHN5bWJvbDogc3ltYm9sKSA9PiB7XG5cdFx0b2RwKE1uZW1vbmljYS5wcm90b3R5cGUsIHN5bWJvbCwge1xuXHRcdFx0Z2V0ICgpIHtcblx0XHRcdFx0Y29uc3Qgc3ltYm9sTWV0aG9kID0gUmVmbGVjdC5nZXQoTW5lbW9uaWNhUHJvdG9Qcm9wcywgc3ltYm9sKTtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuXHRcdFx0XHQvLyBAdHMtaWdub3JlXG5cdFx0XHRcdHJldHVybiBzeW1ib2xNZXRob2QuY2FsbCh0aGlzKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cblx0Ly8gaW5zdGFuY2Ugb2Ygc2VsZiBDb25zdHJ1Y3RvciB0eXBlXG5cdG9kcChNbmVtb25pY2EucHJvdG90eXBlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcblx0XHRnZXQgKCkge1xuXHRcdFx0cmV0dXJuIGdldFR5cGVDaGVja2VyKHRoaXMuY29uc3RydWN0b3IubmFtZSk7XG5cdFx0fVxuXHR9KTtcblxuXHRjb25zdCBwcm90byA9IG5ldyBNbmVtb25pY2EoKTtcblx0UmVmbGVjdC5zZXRQcm90b3R5cGVPZihpbnN0YW5jZSwgcHJvdG8pO1xuXG5cdC8vIEluc3RhbmNlUm9vdHMuc2V0KGluc3RhbmNlLCBwcm90byk7XG5cbn0gYXMgQ29uc3RydWN0b3JGdW5jdGlvbjx0eXBlb2YgTW5lbW9uaWNhUHJvdG9Qcm9wcz47XG5cbmNvbnN0IGNyZWF0ZU1uZW1vc3luZSA9IGZ1bmN0aW9uIChVcmFudXM6IHVua25vd24pIHtcbi8vIGNvbnN0IGNyZWF0ZU1uZW1vc3luZSA9IGZ1bmN0aW9uIChVcmFudXM6IHVua25vd24sIHR5cGVQcm94eTogdW5rbm93bikge1xuLy8gXHRpZiAodHlwZW9mIFVyYW51cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbi8vIFx0XHRjb25zdCB7IF9fdHlwZV9fOiB0eXBlLCBVcmFudXM6IF91cmFudXMgfSA9IHR5cGVQcm94eTtcbi8vIFx0XHRjb25zb2xlLmxvZyh0eXBlLCBfdXJhbnVzKTtcbi8vIFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZGVidWdnZXJcbi8vIFx0XHRkZWJ1Z2dlcjtcbi8vIFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2NyZWF0ZU1uZW1vc3luZSBVcmFudXMgaXMgbm90IGRlZmluZWQgZm9yIHR5cGVQcm94eS4nKTtcbi8vIFx0fVxuXG5cdGNvbnN0IHVyYW51cyA9IHJlZmxlY3RQcmltaXRpdmVXcmFwcGVycyhVcmFudXMpO1xuXHRjb25zdCBtbmVtb3N5bmUgPSBuZXcgTW5lbW9zeW5lKHVyYW51cyk7XG5cdGNvbnN0IG1uZW1vc3luZVByb3h5ID0gbmV3IFByb3h5KG1uZW1vc3luZSwge1xuXHRcdGdldCA6IG1uZW1vc3luZVByb3h5SGFuZGxlckdldFxuXHR9KTtcblxuXHRyZXR1cm4gbW5lbW9zeW5lUHJveHk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cdGdldCBjcmVhdGVNbmVtb3N5bmUgKCkge1xuXHRcdHJldHVybiBjcmVhdGVNbmVtb3N5bmU7XG5cdH0sXG5cdGdldCBwcmVwYXJlU3VidHlwZUZvckNvbnN0cnVjdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHByZXBhcmVTdWJ0eXBlRm9yQ29uc3RydWN0aW9uO1xuXHR9LFxuXHRnZXQgZ2V0RGVmYXVsdFByb3RvdHlwZSAoKSB7XG5cdFx0cmV0dXJuIGdldERlZmF1bHRQcm90b3R5cGU7XG5cdH0sXG5cdC8vIGdldCBNbmVtb3N5bmVQcm90b3R5cGVLZXlzICgpIHtcblx0Ly8gXHRyZXR1cm4gTW5lbW9zeW5lUHJvdG90eXBlS2V5cztcblx0Ly8gfSxcblx0Ly8gZ2V0IEluc3RhbmNlUm9vdHMgKCkge1xuXHQvLyBcdHJldHVybiBJbnN0YW5jZVJvb3RzO1xuXHQvLyB9XG59O1xuIl19