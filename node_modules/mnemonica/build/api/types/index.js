'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.lookup = exports.define = void 0;
const hop_1 = require("../../utils/hop");
const constants_1 = require("../../constants");
const { odp, SymbolParentType, SymbolConstructorName, SymbolConfig, TYPE_TITLE_PREFIX, MNEMOSYNE, } = constants_1.constants;
const errors_1 = require("../../descriptors/errors");
const Mnemosyne_1 = require("./Mnemosyne");
const { getDefaultPrototype } = Mnemosyne_1.default;
const { ALREADY_DECLARED, WRONG_TYPE_DEFINITION, TYPENAME_MUST_BE_A_STRING, HANDLER_MUST_BE_A_FUNCTION, } = errors_1.ErrorsTypes;
const hooksApi = require("../hooks");
const TypeProxy_1 = require("./TypeProxy");
const compileNewModificatorFunctionBody_1 = require("./compileNewModificatorFunctionBody");
const utils_1 = require("../utils");
const { getTypeChecker, CreationHandler, getTypeSplitPath, checkTypeName, isClass, } = utils_1.default;
const errors_2 = require("../errors");
const TypeDescriptor = function (defineOrigin, types, TypeName, constructHandler, proto, config) {
    const parentType = types[SymbolParentType] || null;
    const isSubType = parentType ? true : false;
    const collection = isSubType
        ? parentType.collection
        : types[MNEMOSYNE];
    if (types.has(TypeName)) {
        throw new ALREADY_DECLARED;
    }
    const subtypes = new Map();
    const title = `${TYPE_TITLE_PREFIX}${TypeName}`;
    config = Object.assign({}, collection[SymbolConfig], config);
    const type = Object.assign(this, {
        get constructHandler() {
            return constructHandler;
        },
        TypeName,
        proto,
        isSubType,
        subtypes,
        parentType,
        collection,
        title,
        config,
        hooks: Object.create(null)
    });
    errors_2.getStack.call(this, `Definition of [ ${TypeName} ] made at:`, [], defineOrigin);
    odp(subtypes, SymbolParentType, {
        get() {
            return type;
        }
    });
    const Uranus = isSubType ? undefined : proto;
    types.set(TypeName, new TypeProxy_1.TypeProxy(type, Uranus));
    return types.get(TypeName);
};
Object.assign(TypeDescriptor.prototype, hooksApi);
TypeDescriptor.prototype.define = function (TypeOrTypeName, constructHandlerOrConfig, config) {
    return exports.define.call(exports.define, this.subtypes, TypeOrTypeName, constructHandlerOrConfig, config);
};
TypeDescriptor.prototype.lookup = function (TypeNestedPath) {
    return exports.lookup.call(this.subtypes, TypeNestedPath);
};
odp(TypeDescriptor.prototype, Symbol.hasInstance, {
    get() {
        return getTypeChecker(this.TypeName);
    }
});
const defineUsingType = function (subtypes, constructHandlerGetter, config) {
    const type = constructHandlerGetter();
    if (typeof type !== 'function') {
        throw new HANDLER_MUST_BE_A_FUNCTION;
    }
    const TypeName = type.name;
    if (!TypeName) {
        throw new TYPENAME_MUST_BE_A_STRING;
    }
    const asClass = isClass(type);
    const makeConstructHandler = () => {
        const constructHandler = constructHandlerGetter();
        odp(constructHandler, SymbolConstructorName, {
            get() {
                return TypeName;
            }
        });
        const protoDesc = Object
            .getOwnPropertyDescriptor(constructHandler, 'prototype');
        if (protoDesc && protoDesc.writable) {
            constructHandler.prototype = getDefaultPrototype();
        }
        return constructHandler;
    };
    if (typeof config === 'object') {
        config = Object.assign({}, config);
    }
    else {
        config = {};
    }
    config.asClass = asClass;
    return new TypeDescriptor(this, subtypes, TypeName, makeConstructHandler, type.prototype, config);
};
const defineUsingFunction = function (subtypes, TypeName, constructHandler = function () { }, config = {}) {
    if (typeof constructHandler !== 'function') {
        throw new HANDLER_MUST_BE_A_FUNCTION;
    }
    const asClass = isClass(constructHandler);
    const modificatorBody = (0, compileNewModificatorFunctionBody_1.default)(TypeName, asClass);
    const makeConstructHandler = modificatorBody(constructHandler, CreationHandler, SymbolConstructorName);
    if (config instanceof Function) {
        config = {
            ModificationConstructor: config
        };
    }
    if (typeof config !== 'object') {
        config = {};
    }
    config.asClass = asClass;
    const proto = ((0, hop_1.hop)(constructHandler, 'prototype') &&
        (typeof constructHandler.prototype === 'object')) ? constructHandler.prototype : getDefaultPrototype();
    return new TypeDescriptor(this, subtypes, TypeName, makeConstructHandler, proto, config);
};
const define = function (subtypes, TypeOrTypeName, constructHandlerOrConfig, config) {
    if (typeof TypeOrTypeName === 'function') {
        if (TypeOrTypeName.name) {
            return exports.define.call(this, subtypes, TypeOrTypeName.name, TypeOrTypeName, config);
        }
        else {
            return defineUsingType.call(this, subtypes, TypeOrTypeName, constructHandlerOrConfig);
        }
    }
    if (typeof TypeOrTypeName === 'string') {
        checkTypeName(TypeOrTypeName);
        const split = getTypeSplitPath(TypeOrTypeName);
        const Type = exports.lookup.call(subtypes, split[0]);
        if (!Type) {
            if (split.length === 1) {
                return defineUsingFunction.call(this, subtypes, TypeOrTypeName, constructHandlerOrConfig, config);
            }
            throw new WRONG_TYPE_DEFINITION(`${split[0]} definition is not yet exists`);
        }
        const TypeName = split.slice(1).join('.');
        if (split.length > 1) {
            return exports.define.call(this, Type.subtypes, TypeName, constructHandlerOrConfig, config);
        }
        return exports.define.call(this, Type.subtypes, constructHandlerOrConfig, config);
    }
    throw new WRONG_TYPE_DEFINITION('definition is not provided');
};
exports.define = define;
const lookup = function (TypeNestedPath) {
    if (typeof TypeNestedPath !== 'string') {
        throw new WRONG_TYPE_DEFINITION('arg : type nested path must be a string');
    }
    if (!TypeNestedPath.length) {
        throw new WRONG_TYPE_DEFINITION('arg : type nested path has no path');
    }
    const split = getTypeSplitPath(TypeNestedPath);
    const [name] = split;
    const type = this.get(name);
    if (split.length === 1) {
        return type;
    }
    const NextNestedPath = split.slice(1).join('.');
    if (!type) {
        return undefined;
    }
    return exports.lookup.call(type.subtypes, NextNestedPath);
};
exports.lookup = lookup;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvYXBpL3R5cGVzL2luZGV4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFlBQVksQ0FBQzs7O0FBU2IseUNBQXNDO0FBRXRDLCtDQUE0QztBQUM1QyxNQUFNLEVBQ0wsR0FBRyxFQUNILGdCQUFnQixFQUNoQixxQkFBcUIsRUFDckIsWUFBWSxFQUVaLGlCQUFpQixFQUNqQixTQUFTLEdBRVQsR0FBRyxxQkFBUyxDQUFDO0FBRWQscURBQXVEO0FBR3ZELDJDQUFxQztBQUNyQyxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsR0FBRyxtQkFBVSxDQUFDO0FBRTNDLE1BQU0sRUFDTCxnQkFBZ0IsRUFDaEIscUJBQXFCLEVBQ3JCLHlCQUF5QixFQUN6QiwwQkFBMEIsR0FDMUIsR0FBRyxvQkFBVyxDQUFDO0FBS2hCLHFDQUFxQztBQUNyQywyQ0FBd0M7QUFFeEMsMkZBQW9GO0FBRXBGLG9DQUFrQztBQUNsQyxNQUFNLEVBQ0wsY0FBYyxFQUNkLGVBQWUsRUFDZixnQkFBZ0IsRUFDaEIsYUFBYSxFQUNiLE9BQU8sR0FDUCxHQUFHLGVBQVUsQ0FBQztBQUVmLHNDQUFxQztBQUVyQyxNQUFNLGNBQWMsR0FBRyxVQUV0QixZQUE4QixFQUM5QixLQUEwQixFQUMxQixRQUFnQixFQUNoQixnQkFBa0MsRUFDbEMsS0FBcUMsRUFDckMsTUFBc0M7SUFLdEMsTUFBTSxVQUFVLEdBQUksS0FBMkMsQ0FBRSxnQkFBZ0IsQ0FBRSxJQUFJLElBQUksQ0FBQztJQUU1RixNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBRTVDLE1BQU0sVUFBVSxHQUFHLFNBQVM7UUFDM0IsQ0FBQyxDQUFFLFVBQXNDLENBQUMsVUFBb0I7UUFDOUQsQ0FBQyxDQUFFLEtBQW9ELENBQUUsU0FBUyxDQUFFLENBQUM7SUFFdEUsSUFBSyxLQUFL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cEVXLFFBQUEsTUFBTSxVQW9FakI7QUFFSyxNQUFNLE1BQU0sR0FBRyxVQUVyQixjQUFzQjtJQUd0QixJQUFLLE9BQU8sY0FBYyxLQUFLLFFBQVEsRUFBRyxDQUFDO1FBQzFDLE1BQU0sSUFBSSxxQkFBcUIsQ0FBRSx5Q0FBeUMsQ0FBRSxDQUFDO0lBQzlFLENBQUM7SUFFRCxJQUFLLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRyxDQUFDO1FBQzlCLE1BQU0sSUFBSSxxQkFBcUIsQ0FBRSxvQ0FBb0MsQ0FBRSxDQUFDO0lBQ3pFLENBQUM7SUFFRCxNQUFNLEtBQUssR0FBRyxnQkFBZ0IsQ0FBRSxjQUFjLENBQUUsQ0FBQztJQUVqRCxNQUFNLENBQUUsSUFBSSxDQUFFLEdBQUcsS0FBSyxDQUFDO0lBQ3ZCLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUUsSUFBSSxDQUEyQixDQUFDO0lBQ3ZELElBQUssS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUcsQ0FBQztRQUMxQixPQUFPLElBQUksQ0FBQztJQUNiLENBQUM7SUFFRCxNQUFNLGNBQWMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFFLENBQUMsQ0FBRSxDQUFDLElBQUksQ0FBRSxHQUFHLENBQUUsQ0FBQztJQUNwRCxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDWCxPQUFPLFNBQVMsQ0FBQztJQUNsQixDQUFDO0lBQ0QsT0FBTyxjQUFNLENBQUMsSUFBSSxDQUFFLElBQUksQ0FBQyxRQUErQixFQUFFLGNBQWMsQ0FBRSxDQUFDO0FBRTVFLENBQUMsQ0FBQztBQTNCVyxRQUFBLE1BQU0sVUEyQmpCIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge1xuXHRDb25zdHJ1Y3RvckZ1bmN0aW9uLFxuXHRUeXBlRGVzY3JpcHRvckluc3RhbmNlLFxuXHRUeXBlQ2xhc3MsXG5cdGNvbnN0cnVjdG9yT3B0aW9uc1xufSBmcm9tICcuLi8uLi90eXBlcyc7XG5cbmltcG9ydCB7IGhvcCB9IGZyb20gJy4uLy4uL3V0aWxzL2hvcCc7XG5cbmltcG9ydCB7IGNvbnN0YW50cyB9IGZyb20gJy4uLy4uL2NvbnN0YW50cyc7XG5jb25zdCB7XG5cdG9kcCxcblx0U3ltYm9sUGFyZW50VHlwZSxcblx0U3ltYm9sQ29uc3RydWN0b3JOYW1lLFxuXHRTeW1ib2xDb25maWcsXG5cblx0VFlQRV9USVRMRV9QUkVGSVgsXG5cdE1ORU1PU1lORSxcblxufSA9IGNvbnN0YW50cztcblxuaW1wb3J0IHsgRXJyb3JzVHlwZXMgfSBmcm9tICcuLi8uLi9kZXNjcmlwdG9ycy9lcnJvcnMnO1xuLy8gaW1wb3J0IHsgZGVzY3JpcHRvcnMgfSBmcm9tICcuLi8uLi9kZXNjcmlwdG9ycyc7XG5cbmltcG9ydCBtbmVtb3N5bmVzIGZyb20gJy4vTW5lbW9zeW5lJztcbmNvbnN0IHsgZ2V0RGVmYXVsdFByb3RvdHlwZSB9ID0gbW5lbW9zeW5lcztcblxuY29uc3Qge1xuXHRBTFJFQURZX0RFQ0xBUkVELFxuXHRXUk9OR19UWVBFX0RFRklOSVRJT04sXG5cdFRZUEVOQU1FX01VU1RfQkVfQV9TVFJJTkcsXG5cdEhBTkRMRVJfTVVTVF9CRV9BX0ZVTkNUSU9OLFxufSA9IEVycm9yc1R5cGVzO1xuXG4vLyBpbnZva2VIb29rXG4vLyByZWdpc3Rlckhvb2tcbi8vIHJlZ2lzdGVyRmxvd0NoZWNrZXJcbmltcG9ydCAqIGFzIGhvb2tzQXBpIGZyb20gJy4uL2hvb2tzJztcbmltcG9ydCB7IFR5cGVQcm94eSB9IGZyb20gJy4vVHlwZVByb3h5JztcblxuaW1wb3J0IGNvbXBpbGVOZXdNb2RpZmljYXRvckZ1bmN0aW9uQm9keSBmcm9tICcuL2NvbXBpbGVOZXdNb2RpZmljYXRvckZ1bmN0aW9uQm9keSc7XG5cbmltcG9ydCBUeXBlc1V0aWxzIGZyb20gJy4uL3V0aWxzJztcbmNvbnN0IHtcblx0Z2V0VHlwZUNoZWNrZXIsXG5cdENyZWF0aW9uSGFuZGxlcixcblx0Z2V0VHlwZVNwbGl0UGF0aCxcblx0Y2hlY2tUeXBlTmFtZSxcblx0aXNDbGFzcyxcbn0gPSBUeXBlc1V0aWxzO1xuXG5pbXBvcnQgeyBnZXRTdGFjayB9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmNvbnN0IFR5cGVEZXNjcmlwdG9yID0gZnVuY3Rpb24gKFxuXHR0aGlzOiBUeXBlRGVzY3JpcHRvckluc3RhbmNlLFxuXHRkZWZpbmVPcmlnaW46IENhbGxhYmxlRnVuY3Rpb24sXG5cdHR5cGVzOiBNYXA8c3RyaW5nLCBvYmplY3Q+LFxuXHRUeXBlTmFtZTogc3RyaW5nLFxuXHRjb25zdHJ1Y3RIYW5kbGVyOiBDYWxsYWJsZUZ1bmN0aW9uLFxuXHRwcm90bzogeyBbIGluZGV4OiBzdHJpbmcgXTogdW5rbm93biB9LFxuXHRjb25maWc6IHsgWyBpbmRleDogc3RyaW5nIF06IHVua25vd24gfSxcbikge1xuXG5cdC8vIGhlcmUgXCJ0eXBlc1wiIHJlZmVycyB0byBzdWJ0eXBlcyBvZiB0eXBlIG9yIGNvbGxlY3Rpb24gb2JqZWN0IHt9XG5cblx0Y29uc3QgcGFyZW50VHlwZSA9ICh0eXBlcyBhcyB1bmtub3duIGFzIFJlY29yZDxzeW1ib2wsIG9iamVjdD4pWyBTeW1ib2xQYXJlbnRUeXBlIF0gfHwgbnVsbDtcblxuXHRjb25zdCBpc1N1YlR5cGUgPSBwYXJlbnRUeXBlID8gdHJ1ZSA6IGZhbHNlO1xuXG5cdGNvbnN0IGNvbGxlY3Rpb24gPSBpc1N1YlR5cGVcblx0XHQ/IChwYXJlbnRUeXBlIGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KS5jb2xsZWN0aW9uIGFzIG9iamVjdFxuXHRcdDogKHR5cGVzIGFzIHVua25vd24gYXMgUmVjb3JkPHN0cmluZyB8IHN5bWJvbCwgb2JqZWN0PilbIE1ORU1PU1lORSBdO1xuXG5cdGlmICggdHlwZXMuaGFzKCBUeXBlTmFtZSApICkge1xuXHRcdHRocm93IG5ldyBBTFJFQURZX0RFQ0xBUkVEO1xuXHR9XG5cblx0Ly8gY29uc3Qgc3VidHlwZXMgPSBkZXNjcmlwdG9ycy5jcmVhdGVUeXBlc0NvbGxlY3Rpb24oKTtcblx0Y29uc3Qgc3VidHlwZXMgPSBuZXcgTWFwPHN0cmluZywgb2JqZWN0PigpO1xuXG5cdGNvbnN0IHRpdGxlID0gYCR7VFlQRV9USVRMRV9QUkVGSVh9JHtUeXBlTmFtZX1gO1xuXG5cdGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oIHt9LCAoY29sbGVjdGlvbiBhcyBSZWNvcmQ8c3ltYm9sLCB1bmtub3duPilbIFN5bWJvbENvbmZpZyBdLCBjb25maWcgKTtcblxuXHRjb25zdCB0eXBlID0gT2JqZWN0LmFzc2lnbiggdGhpcywge1xuXG5cdFx0Z2V0IGNvbnN0cnVjdEhhbmRsZXIgKCkge1xuXHRcdFx0cmV0dXJuIGNvbnN0cnVjdEhhbmRsZXI7XG5cdFx0fSxcblxuXG5cdFx0VHlwZU5hbWUsXG5cdFx0cHJvdG8sXG5cblx0XHRpc1N1YlR5cGUsXG5cdFx0c3VidHlwZXMsXG5cdFx0cGFyZW50VHlwZSxcblxuXHRcdGNvbGxlY3Rpb24sXG5cblx0XHR0aXRsZSxcblxuXHRcdGNvbmZpZyxcblxuXHRcdGhvb2tzIDogT2JqZWN0LmNyZWF0ZSggbnVsbCApXG5cblx0fSApO1xuXG5cdGdldFN0YWNrLmNhbGwoIHRoaXMsIGBEZWZpbml0aW9uIG9mIFsgJHtUeXBlTmFtZX0gXSBtYWRlIGF0OmAsIFtdLCBkZWZpbmVPcmlnaW4gKTtcblxuXHRvZHAoIHN1YnR5cGVzLCBTeW1ib2xQYXJlbnRUeXBlLCB7XG5cdFx0Z2V0ICgpIHtcblx0XHRcdHJldHVybiB0eXBlO1xuXHRcdH1cblx0fSApO1xuXG5cdC8vIGNvbnN0IFVyYW51cyA9IGlzU3ViVHlwZSA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBwcm90bztcblx0Y29uc3QgVXJhbnVzID0gaXNTdWJUeXBlID8gdW5kZWZpbmVkIDogcHJvdG87XG5cdHR5cGVzLnNldCggVHlwZU5hbWUsIG5ldyBUeXBlUHJveHkoIHR5cGUsIFVyYW51cyApICk7XG5cdFxuXHQvLyB0eXBlcy5zZXQoIFR5cGVOYW1lLCBuZXcgVHlwZVByb3h5KCB0eXBlICkgKTtcblxuXHRyZXR1cm4gdHlwZXMuZ2V0KCBUeXBlTmFtZSApO1xuXG59IGFzIHVua25vd24gYXMgQ29uc3RydWN0b3JGdW5jdGlvbjxUeXBlRGVzY3JpcHRvckluc3RhbmNlPjtcblxuT2JqZWN0LmFzc2lnbiggVHlwZURlc2NyaXB0b3IucHJvdG90eXBlLCBob29rc0FwaSApO1xuXG5UeXBlRGVzY3JpcHRvci5wcm90b3R5cGUuZGVmaW5lID0gZnVuY3Rpb24gKFxuXHR0aGlzOiBUeXBlRGVzY3JpcHRvckluc3RhbmNlLFxuXHRUeXBlT3JUeXBlTmFtZTogc3RyaW5nIHwgQ2FsbGFibGVGdW5jdGlvbixcblx0Y29uc3RydWN0SGFuZGxlck9yQ29uZmlnPzogQ2FsbGFibGVGdW5jdGlvbiB8IG9iamVjdCxcblx0Y29uZmlnPzogb2JqZWN0XG4pIHtcblx0cmV0dXJuIGRlZmluZS5jYWxsKCBkZWZpbmUsIHRoaXMuc3VidHlwZXMgYXMgTWFwPHN0cmluZywgb2JqZWN0PiwgVHlwZU9yVHlwZU5hbWUsIGNvbnN0cnVjdEhhbmRsZXJPckNvbmZpZywgY29uZmlnICk7XG59O1xuXG5UeXBlRGVzY3JpcHRvci5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gKFxuXHR0aGlzOiBUeXBlRGVzY3JpcHRvckluc3RhbmNlLFxuXHRUeXBlTmVzdGVkUGF0aDogc3RyaW5nXG4pIHtcblx0cmV0dXJuIGxvb2t1cC5jYWxsKCB0aGlzLnN1YnR5cGVzIGFzIE1hcDxzdHJpbmcsIG9iamVjdD4sIFR5cGVOZXN0ZWRQYXRoICk7XG59O1xuXG5vZHAoIFR5cGVEZXNjcmlwdG9yLnByb3RvdHlwZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG5cdGdldCAodGhpczogVHlwZURlc2NyaXB0b3JJbnN0YW5jZSkge1xuXHRcdHJldHVybiBnZXRUeXBlQ2hlY2tlciggdGhpcy5UeXBlTmFtZSApO1xuXHR9XG59ICk7XG5cbi8qXG5oZXJlIHdlIHVzZSBmdW5jdGlvbiB0byByZXRyZWl2ZSBhIGNvbnRydWN0b3JcbmFuZCBjb25zdHJ1Y3RIYW5kbGVyR2V0dGVyIGlzIHRoYXQgZnVuY3Rpb25cbiovXG5jb25zdCBkZWZpbmVVc2luZ1R5cGUgPSBmdW5jdGlvbiAoXG5cdHRoaXM6IENhbGxhYmxlRnVuY3Rpb24sXG5cdHN1YnR5cGVzOiBNYXA8c3RyaW5nLCBvYmplY3Q+LFxuXHRjb25zdHJ1Y3RIYW5kbGVyR2V0dGVyOiAoKSA9PiBDYWxsYWJsZUZ1bmN0aW9uLFxuXHRjb25maWc6IGNvbnN0cnVjdG9yT3B0aW9ucyB8IHVuZGVmaW5lZFxuKSB7XG5cdC8vIHdlIG5lZWQgdGhpcyB0byBleHRyYWN0IFR5cGVOYW1lXG5cdGNvbnN0IHR5cGUgPSBjb25zdHJ1Y3RIYW5kbGVyR2V0dGVyKCk7XG5cblx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHR0aHJvdyBuZXcgSEFORExFUl9NVVNUX0JFX0FfRlVOQ1RJT047XG5cdH1cblxuXHRjb25zdCBUeXBlTmFtZSA9IHR5cGUubmFtZTtcblxuXHRpZiAoICFUeXBlTmFtZSApIHtcblx0XHR0aHJvdyBuZXcgVFlQRU5BTUVfTVVTVF9CRV9BX1NUUklORztcblx0fVxuXG5cdGNvbnN0IGFzQ2xhc3MgPSBpc0NsYXNzKCB0eXBlICk7XG5cblx0Y29uc3QgbWFrZUNvbnN0cnVjdEhhbmRsZXIgPSAoKSA9PiB7XG5cdFx0Y29uc3QgY29uc3RydWN0SGFuZGxlciA9IGNvbnN0cnVjdEhhbmRsZXJHZXR0ZXIoKTtcblx0XHQvLyBjb25zdHJ1Y3RIYW5kbGVyW1N5bWJvbENvbnN0cnVjdG9yTmFtZV0gPSBUeXBlTmFtZTtcblx0XHRvZHAoIGNvbnN0cnVjdEhhbmRsZXIsIFN5bWJvbENvbnN0cnVjdG9yTmFtZSwge1xuXHRcdFx0Z2V0ICgpIHtcblx0XHRcdFx0cmV0dXJuIFR5cGVOYW1lO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRcblx0XHQvLyB0aGlzIHdhcyBjaGVja2luZyBmb3IgY2xhc3MgLyBmdW5jdGlvblxuXHRcdC8vIGZ1bmN0aW9ucyBoYXMgLndyaXRhYmxlIHByb3RvdHlwZVxuXHRcdC8vIGFuZCBjbGFzc2VzIGFyZSBoYXMgbm90XG5cdFx0Y29uc3QgcHJvdG9EZXNjID0gT2JqZWN0XG5cdFx0XHQuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCBjb25zdHJ1Y3RIYW5kbGVyLCAncHJvdG90eXBlJyApIGFzIFByb3BlcnR5RGVzY3JpcHRvciB8IHVuZGVmaW5lZDtcblx0XHRpZiAoIHByb3RvRGVzYyAmJiBwcm90b0Rlc2Mud3JpdGFibGUgKSB7XG5cdFx0XHQvLyBjb25zdHJ1Y3RIYW5kbGVyLnByb3RvdHlwZSA9IHt9O1xuXHRcdFx0Y29uc3RydWN0SGFuZGxlci5wcm90b3R5cGUgPSBnZXREZWZhdWx0UHJvdG90eXBlKCk7XG5cdFx0fVxuXHRcdFxuXHRcdC8vIFRPRE86XG5cdFx0Ly8gc2lkZS13YXksIG5vbiBjb3JyZWN0bHkgd29ya2luZ1xuXHRcdC8vIHdpdGggY3JlYXRlSW5zdGFuY2VNb2RpZmljYXRvciBmb3IgbGluZVxuXHRcdC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1vZGlmaWNhdG9yVHlwZS5wcm90b3R5cGUsIHByb3BzKTtcblx0XHQvLyBmb3IgcmVwZWF0YWJsZSBpbnN0YW5jZSBjcmVhdGlvbnNcblx0XHQvLyDihpPihpPihpMg4oaT4oaT4oaTIOKGk+KGk+KGk1xuXHRcdC8vIGVsc2Uge1xuXHRcdC8vIFx0Ly8gc28gbGV0IHVzZSBPYmplY3Quc2V0UHJvdG90eXBlT2YgaW5zdGVhZFxuXHRcdC8vIFx0Ly8gT2JqZWN0LnNldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZihjb25zdHJ1Y3RIYW5kbGVyLnByb3RvdHlwZSksIGdldERlZmF1bHRQcm90b3R5cGUoKSk7XG5cdFx0Ly8gXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoY29uc3RydWN0SGFuZGxlci5wcm90b3R5cGUsIGdldERlZmF1bHRQcm90b3R5cGUoKSk7XG5cdFx0Ly8gfVxuXG5cdFx0cmV0dXJuIGNvbnN0cnVjdEhhbmRsZXI7XG5cdH07XG5cblx0aWYgKCB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyApIHtcblx0XHRjb25maWcgPSBPYmplY3QuYXNzaWduKCB7fSwgY29uZmlnICk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uZmlnID0ge307XG5cdH1cblxuXHRjb25maWcuYXNDbGFzcyA9IGFzQ2xhc3M7XG5cblx0cmV0dXJuIG5ldyBUeXBlRGVzY3JpcHRvcihcblx0XHR0aGlzLFxuXHRcdHN1YnR5cGVzLFxuXHRcdFR5cGVOYW1lLFxuXHRcdG1ha2VDb25zdHJ1Y3RIYW5kbGVyLFxuXHRcdHR5cGUucHJvdG90eXBlLFxuXHRcdGNvbmZpZ1xuXHQpO1xufTtcblxuXG4vKlxuaGVyZSB3ZSBkaXJlY3RseSBwYXNzaW5nIGNvbnN0cnVjdEhhbmRsZXJcbmFzIGEgY29uc3RydWN0b3IgZm9yIGluc3RhbmNlcyBjcmVhdGlvbnNcbiovXG5jb25zdCBkZWZpbmVVc2luZ0Z1bmN0aW9uID0gZnVuY3Rpb24gKFxuXHR0aGlzOiBDYWxsYWJsZUZ1bmN0aW9uLFxuXHRzdWJ0eXBlczogTWFwPHN0cmluZywgb2JqZWN0Pixcblx0VHlwZU5hbWU6IHN0cmluZyxcblx0Y29uc3RydWN0SGFuZGxlcjogQ2FsbGFibGVGdW5jdGlvbiA9IGZ1bmN0aW9uICgpIHsgfSxcblx0Y29uZmlnOiBjb25zdHJ1Y3Rvck9wdGlvbnMgPSB7fVxuKSB7XG5cblx0aWYgKCB0eXBlb2YgY29uc3RydWN0SGFuZGxlciAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHR0aHJvdyBuZXcgSEFORExFUl9NVVNUX0JFX0FfRlVOQ1RJT047XG5cdH1cblxuXHRjb25zdCBhc0NsYXNzID0gaXNDbGFzcyggY29uc3RydWN0SGFuZGxlciApO1xuXHRjb25zdCBtb2RpZmljYXRvckJvZHkgPSBjb21waWxlTmV3TW9kaWZpY2F0b3JGdW5jdGlvbkJvZHkoIFR5cGVOYW1lLCBhc0NsYXNzICk7XG5cblx0Y29uc3QgbWFrZUNvbnN0cnVjdEhhbmRsZXIgPSBtb2RpZmljYXRvckJvZHkoXG5cdFx0Y29uc3RydWN0SGFuZGxlcixcblx0XHRDcmVhdGlvbkhhbmRsZXIsXG5cdFx0U3ltYm9sQ29uc3RydWN0b3JOYW1lXG5cdCk7XG5cblx0aWYgKCBjb25maWcgaW5zdGFuY2VvZiBGdW5jdGlvbiApIHtcblx0XHRjb25maWcgPSB7XG5cdFx0XHRNb2RpZmljYXRpb25Db25zdHJ1Y3RvciA6IGNvbmZpZ1xuXHRcdH07XG5cdH1cblxuXHRpZiAoIHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnICkge1xuXHRcdGNvbmZpZyA9IHt9O1xuXHR9XG5cblxuXHRjb25maWcuYXNDbGFzcyA9IGFzQ2xhc3M7XG5cblx0Y29uc3QgcHJvdG8gPSAoXG5cdFx0aG9wKCBjb25zdHJ1Y3RIYW5kbGVyLCAncHJvdG90eXBlJyApICYmXG5cdFx0Ly8gdXNpbmcg4oaT4oaT4oaTIGNhdXNlIGZvciBwcm94eSBpbiBjaGFpbiBpcyBpbnN0YW5jZW9mIGZhaWxzXG5cdFx0Ly8gYW5kIGFsc28gZmFpbHMgZm9yIGp1c3QgT2JqZWN0LmNyZWF0ZShudWxsKVxuXHRcdCggdHlwZW9mIGNvbnN0cnVjdEhhbmRsZXIucHJvdG90eXBlID09PSAnb2JqZWN0JyApXG5cdC8vICkgPyBjb25zdHJ1Y3RIYW5kbGVyLnByb3RvdHlwZSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdCkgPyBjb25zdHJ1Y3RIYW5kbGVyLnByb3RvdHlwZSA6IGdldERlZmF1bHRQcm90b3R5cGUoKTtcblx0XG5cdC8vIGxldCBwcm90byA9IHt9O1xuXHQvLyBpZiAoIGhvcCggY29uc3RydWN0SGFuZGxlciwgJ3Byb3RvdHlwZScgKSAmJiAoIGNvbnN0cnVjdEhhbmRsZXIucHJvdG90eXBlIGluc3RhbmNlb2YgT2JqZWN0ICkgKSB7XG5cdC8vIFx0cHJvdG8gPSBPYmplY3QuYXNzaWduKCB7fSwgY29uc3RydWN0SGFuZGxlci5wcm90b3R5cGUgKTtcblx0Ly8gXHRPYmplY3Quc2V0UHJvdG90eXBlT2YoIHByb3RvLCBjb25zdHJ1Y3RIYW5kbGVyLnByb3RvdHlwZSApO1xuXHQvLyB9XG5cblx0cmV0dXJuIG5ldyBUeXBlRGVzY3JpcHRvcihcblx0XHR0aGlzLFxuXHRcdHN1YnR5cGVzLFxuXHRcdFR5cGVOYW1lLFxuXHRcdG1ha2VDb25zdHJ1Y3RIYW5kbGVyLFxuXHRcdC8vIHByb3RvIHByb3AgZm9yIFR5cGVEZXNjcmlwdG9yXG5cdFx0cHJvdG8sXG5cdFx0Y29uZmlnXG5cdCk7XG5cbn07XG5cblxuZXhwb3J0IGNvbnN0IGRlZmluZSA9IGZ1bmN0aW9uIChcblx0dGhpczogQ2FsbGFibGVGdW5jdGlvbixcblx0c3VidHlwZXM6IE1hcDxzdHJpbmcsIG9iamVjdD4sXG5cdFR5cGVPclR5cGVOYW1lOiBzdHJpbmcgfCBDYWxsYWJsZUZ1bmN0aW9uLFxuXHRjb25zdHJ1Y3RIYW5kbGVyT3JDb25maWc/OiBDYWxsYWJsZUZ1bmN0aW9uIHwgb2JqZWN0LFxuXHRjb25maWc/OiBvYmplY3Rcbik6IFR5cGVDbGFzcyB7XG5cblx0aWYgKCB0eXBlb2YgVHlwZU9yVHlwZU5hbWUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0Ly8gVE9ETzogaWYgKCBob3AoIFR5cGVPclR5cGVOYW1lLCAnbmFtZScgKSApIHtcblx0XHQvLyBUT0RPOiBpZiAoIGhvcCggVHlwZU9yVHlwZU5hbWUuY29uc3RydWN0b3IsICduYW1lJyApICkge1xuXHRcdGlmICggVHlwZU9yVHlwZU5hbWUubmFtZSApIHtcblx0XHRcdHJldHVybiBkZWZpbmUuY2FsbCggdGhpcywgc3VidHlwZXMsIFR5cGVPclR5cGVOYW1lLm5hbWUsIFR5cGVPclR5cGVOYW1lLCBjb25maWcgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0IFxuXHRcdFx0cmV0dXJuIChkZWZpbmVVc2luZ1R5cGUgYXMgYW55KS5jYWxsKFxuXHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRzdWJ0eXBlcyxcblx0XHRcdFx0VHlwZU9yVHlwZU5hbWUsXG5cdFx0XHRcdGNvbnN0cnVjdEhhbmRsZXJPckNvbmZpZ1xuXHRcdFx0KTtcblx0XHR9XG5cdH1cblxuXHRpZiAoIHR5cGVvZiBUeXBlT3JUeXBlTmFtZSA9PT0gJ3N0cmluZycgKSB7XG5cblx0XHRjaGVja1R5cGVOYW1lKCBUeXBlT3JUeXBlTmFtZSApO1xuXG5cdFx0Y29uc3Qgc3BsaXQgPSBnZXRUeXBlU3BsaXRQYXRoKCBUeXBlT3JUeXBlTmFtZSApO1xuXG5cdFx0Y29uc3QgVHlwZSA9IGxvb2t1cC5jYWxsKCBzdWJ0eXBlcywgc3BsaXRbIDAgXSApO1xuXG5cdFx0aWYgKCAhVHlwZSApIHtcblxuXHRcdFx0aWYgKCBzcGxpdC5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdCBcblx0XHRcdFx0cmV0dXJuIChkZWZpbmVVc2luZ0Z1bmN0aW9uIGFzIGFueSkuY2FsbChcblx0XHRcdFx0XHR0aGlzLFxuXHRcdFx0XHRcdHN1YnR5cGVzLFxuXHRcdFx0XHRcdFR5cGVPclR5cGVOYW1lLFxuXHRcdFx0XHRcdGNvbnN0cnVjdEhhbmRsZXJPckNvbmZpZyxcblx0XHRcdFx0XHRjb25maWdcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0dGhyb3cgbmV3IFdST05HX1RZUEVfREVGSU5JVElPTiggYCR7c3BsaXRbIDAgXX0gZGVmaW5pdGlvbiBpcyBub3QgeWV0IGV4aXN0c2AgKTtcblx0XHR9XG5cblx0XHRjb25zdCBUeXBlTmFtZSA9IHNwbGl0LnNsaWNlKCAxICkuam9pbiggJy4nICk7XG5cblx0XHRpZiAoIHNwbGl0Lmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRyZXR1cm4gZGVmaW5lLmNhbGwoIHRoaXMsIFR5cGUuc3VidHlwZXMgYXMgTWFwPHN0cmluZywgb2JqZWN0PiwgVHlwZU5hbWUsIGNvbnN0cnVjdEhhbmRsZXJPckNvbmZpZywgY29uZmlnICk7XG5cdFx0fVxuXG5cdFx0Ly8gc28sIGhlcmUgd2UgZ28gd2l0aFxuXHRcdC8vIGRlZmluZVVzaW5nVHlwZS5jYWxsXG5cdFx0Ly8gZnJvbSB0aGUgbmV4dCBzdGVwXG5cdFx0cmV0dXJuIGRlZmluZS5jYWxsKFxuXHRcdFx0dGhpcyBhcyB1bmtub3duIGFzIENhbGxhYmxlRnVuY3Rpb24sXG5cdFx0XHRUeXBlLnN1YnR5cGVzIGFzIE1hcDxzdHJpbmcsIG9iamVjdD4sXG5cdFx0XHRjb25zdHJ1Y3RIYW5kbGVyT3JDb25maWcgYXMgQ2FsbGFibGVGdW5jdGlvbixcblx0XHRcdGNvbmZpZ1xuXHRcdCk7XG5cblx0fVxuXG5cdHRocm93IG5ldyBXUk9OR19UWVBFX0RFRklOSVRJT04oICdkZWZpbml0aW9uIGlzIG5vdCBwcm92aWRlZCcgKTtcblxufTtcblxuZXhwb3J0IGNvbnN0IGxvb2t1cCA9IGZ1bmN0aW9uIChcblx0dGhpczogTWFwPHN0cmluZywgb2JqZWN0Pixcblx0VHlwZU5lc3RlZFBhdGg6IHN0cmluZ1xuKTogVHlwZUNsYXNzIHwgdW5kZWZpbmVkIHtcblxuXHRpZiAoIHR5cGVvZiBUeXBlTmVzdGVkUGF0aCAhPT0gJ3N0cmluZycgKSB7XG5cdFx0dGhyb3cgbmV3IFdST05HX1RZUEVfREVGSU5JVElPTiggJ2FyZyA6IHR5cGUgbmVzdGVkIHBhdGggbXVzdCBiZSBhIHN0cmluZycgKTtcblx0fVxuXG5cdGlmICggIVR5cGVOZXN0ZWRQYXRoLmxlbmd0aCApIHtcblx0XHR0aHJvdyBuZXcgV1JPTkdfVFlQRV9ERUZJTklUSU9OKCAnYXJnIDogdHlwZSBuZXN0ZWQgcGF0aCBoYXMgbm8gcGF0aCcgKTtcblx0fVxuXG5cdGNvbnN0IHNwbGl0ID0gZ2V0VHlwZVNwbGl0UGF0aCggVHlwZU5lc3RlZFBhdGggKTtcblxuXHRjb25zdCBbIG5hbWUgXSA9IHNwbGl0O1xuXHRjb25zdCB0eXBlID0gdGhpcy5nZXQoIG5hbWUgKSBhcyBUeXBlQ2xhc3MgfCB1bmRlZmluZWQ7XG5cdGlmICggc3BsaXQubGVuZ3RoID09PSAxICkge1xuXHRcdHJldHVybiB0eXBlO1xuXHR9XG5cblx0Y29uc3QgTmV4dE5lc3RlZFBhdGggPSBzcGxpdC5zbGljZSggMSApLmpvaW4oICcuJyApO1xuXHRpZiAoIXR5cGUpIHtcblx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHR9XG5cdHJldHVybiBsb29rdXAuY2FsbCggdHlwZS5zdWJ0eXBlcyBhcyBNYXA8c3RyaW5nLCBvYmplY3Q+LCBOZXh0TmVzdGVkUGF0aCApO1xuXG59O1xuXG5cblxuIl19