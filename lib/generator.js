'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.TypesGenerator = void 0;
/**
 * TypeScript declaration file generator
 */
class TypesGenerator {
    constructor(graph) {
        this.graph = graph;
    }
    /**
     * Generate the complete .d.ts file content
     */
    generate() {
        const lines = [];
        const generatedTypes = [];
        // Header
        lines.push('// Generated by @mnemonica/tactica - DO NOT EDIT');
        lines.push('// This file provides TypeScript types for Mnemonica nested constructors');
        lines.push('');
        lines.push("import { IDefinitorInstance, MnemonicaInstance, SN } from 'mnemonica';");
        lines.push('');
        // Generate type registry interface
        lines.push('// Type Registry - maps type names to their instance types');
        lines.push('interface MnemonicaTypeRegistry {');
        for (const root of this.graph.roots.values()) {
            this.generateRegistryEntry(root, lines, 1);
        }
        lines.push('}');
        lines.push('');
        // Generate instance type augmentations
        lines.push('// Augmented instance types with nested constructors');
        lines.push('declare module "mnemonica" {');
        // Generate instance interfaces
        for (const root of this.graph.roots.values()) {
            for (const node of this.graph.dfs(root)) {
                const interfaceName = `${node.name}Instance`;
                generatedTypes.push(interfaceName);
                this.generateInstanceInterface(node, lines, 1);
            }
        }
        lines.push('}');
        lines.push('');
        // Generate type augmentation for constructors
        lines.push('// Augmented constructor types with subtypes');
        lines.push('declare module "mnemonica" {');
        for (const root of this.graph.roots.values()) {
            for (const node of this.graph.dfs(root)) {
                this.generateConstructorAugmentation(node, lines, 1);
            }
        }
        lines.push('}');
        return {
            content: lines.join('\n'),
            types: generatedTypes,
        };
    }
    /**
     * Generate a registry entry for a type node
     */
    generateRegistryEntry(node, lines, indent) {
        const indentStr = '\t'.repeat(indent);
        lines.push(`${indentStr}${node.name}: {`);
        // Properties
        if (node.properties.size > 0) {
            lines.push(`${indentStr}\tproperties: {`);
            for (const prop of node.properties.values()) {
                const optional = prop.optional ? '?' : '';
                lines.push(`${indentStr}\t\t${prop.name}${optional}: ${prop.type};`);
            }
            lines.push(`${indentStr}\t};`);
        }
        // Subtypes
        if (node.children.size > 0) {
            lines.push(`${indentStr}\tsubtypes: {`);
            for (const child of node.children.values()) {
                this.generateRegistryEntry(child, lines, indent + 2);
            }
            lines.push(`${indentStr}\t};`);
        }
        lines.push(`${indentStr}};`);
    }
    /**
     * Generate an instance interface for a type node
     */
    generateInstanceInterface(node, lines, indent) {
        const indentStr = '\t'.repeat(indent);
        const interfaceName = `${node.name}Instance`;
        // Build extends clause
        const extendsTypes = ['MnemonicaInstance'];
        if (node.parent) {
            extendsTypes.unshift(`${node.parent.name}Instance`);
        }
        const extendsClause = extendsTypes.length > 0
            ? ` extends ${extendsTypes.join(', ')}`
            : '';
        lines.push(`${indentStr}interface ${interfaceName}${extendsClause} {`);
        // Add nested constructor properties
        for (const child of node.children.values()) {
            const childInstanceType = `${child.name}Instance`;
            lines.push(`${indentStr}\t${child.name}: IDefinitorInstance<${childInstanceType}, SN>;`);
        }
        lines.push(`${indentStr}}`);
        lines.push('');
    }
    /**
     * Generate constructor augmentation
     */
    generateConstructorAugmentation(node, lines, indent) {
        const indentStr = '\t'.repeat(indent);
        // Build the subtype map
        const subtypeEntries = [];
        for (const child of node.children.values()) {
            subtypeEntries.push(`${child.name}: IDefinitorInstance<${child.name}Instance, SN>`);
        }
        // If we have subtypes, augment the constructor type
        if (subtypeEntries.length > 0) {
            lines.push(`${indentStr}interface ${node.name}Subtypes {`);
            for (const entry of subtypeEntries) {
                lines.push(`${indentStr}\t${entry};`);
            }
            lines.push(`${indentStr}}`);
            lines.push('');
        }
    }
    /**
     * Generate a simple type declaration for a single type
     */
    generateSingleType(node) {
        const lines = [];
        this.generateInstanceInterface(node, lines, 0);
        return lines.join('\n');
    }
}
exports.TypesGenerator = TypesGenerator;
//# sourceMappingURL=generator.js.map