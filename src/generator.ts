'use strict';

import { TypeNode, GeneratedTypes } from './types';
import { TypeGraphImpl } from './graph';

/**
 * TypeScript declaration file generator
 */
export class TypesGenerator {
	constructor(private graph: TypeGraphImpl) {}

	/**
	 * Generate the complete .d.ts file content
	 */
	generate(): GeneratedTypes {
		const lines: string[] = [];
		const generatedTypes: string[] = [];

		// Header
		lines.push('// Generated by @mnemonica/tactica - DO NOT EDIT');
		lines.push('// This file provides TypeScript types for Mnemonica nested constructors');
		lines.push('');
		lines.push("import { IDefinitorInstance, MnemonicaInstance, SN } from 'mnemonica';");
		lines.push('');

		// Generate type registry interface
		lines.push('// Type Registry - maps type names to their instance types');
		lines.push('interface MnemonicaTypeRegistry {');
		for (const root of this.graph.roots.values()) {
			this.generateRegistryEntry(root, lines, 1);
		}
		lines.push('}');
		lines.push('');

		// Generate instance type augmentations
		lines.push('// Augmented instance types with nested constructors');
		lines.push('declare module "mnemonica" {');

		// Generate instance interfaces
		for (const root of this.graph.roots.values()) {
			for (const node of this.graph.dfs(root)) {
				const interfaceName = `${node.name}Instance`;
				generatedTypes.push(interfaceName);
				this.generateInstanceInterface(node, lines, 1);
			}
		}

		lines.push('}');
		lines.push('');

		// Generate type augmentation for constructors
		lines.push('// Augmented constructor types with subtypes');
		lines.push('declare module "mnemonica" {');
		for (const root of this.graph.roots.values()) {
			for (const node of this.graph.dfs(root)) {
				this.generateConstructorAugmentation(node, lines, 1);
			}
		}
		lines.push('}');

		return {
			content: lines.join('\n'),
			types: generatedTypes,
		};
	}

	/**
	 * Generate a registry entry for a type node
	 */
	private generateRegistryEntry(node: TypeNode, lines: string[], indent: number): void {
		const indentStr = '\t'.repeat(indent);
		lines.push(`${indentStr}${node.name}: {`);

		// Properties
		if (node.properties.size > 0) {
			lines.push(`${indentStr}\tproperties: {`);
			for (const prop of node.properties.values()) {
				const optional = prop.optional ? '?' : '';
				lines.push(`${indentStr}\t\t${prop.name}${optional}: ${prop.type};`);
			}
			lines.push(`${indentStr}\t};`);
		}

		// Subtypes
		if (node.children.size > 0) {
			lines.push(`${indentStr}\tsubtypes: {`);
			for (const child of node.children.values()) {
				this.generateRegistryEntry(child, lines, indent + 2);
			}
			lines.push(`${indentStr}\t};`);
		}

		lines.push(`${indentStr}};`);
	}

	/**
	 * Generate an instance interface for a type node
	 */
	private generateInstanceInterface(node: TypeNode, lines: string[], indent: number): void {
		const indentStr = '\t'.repeat(indent);
		const interfaceName = `${node.name}Instance`;

		// Build extends clause
		const extendsTypes: string[] = ['MnemonicaInstance'];
		if (node.parent) {
			extendsTypes.unshift(`${node.parent.name}Instance`);
		}

		const extendsClause = extendsTypes.length > 0
			? ` extends ${extendsTypes.join(', ')}`
			: '';

		lines.push(`${indentStr}interface ${interfaceName}${extendsClause} {`);

		// Add nested constructor properties
		for (const child of node.children.values()) {
			const childInstanceType = `${child.name}Instance`;
			lines.push(`${indentStr}\t${child.name}: IDefinitorInstance<${childInstanceType}, SN>;`);
		}

		lines.push(`${indentStr}}`);
		lines.push('');
	}

	/**
	 * Generate constructor augmentation
	 */
	private generateConstructorAugmentation(node: TypeNode, lines: string[], indent: number): void {
		const indentStr = '\t'.repeat(indent);

		// Build the subtype map
		const subtypeEntries: string[] = [];
		for (const child of node.children.values()) {
			subtypeEntries.push(`${child.name}: IDefinitorInstance<${child.name}Instance, SN>`);
		}

		// If we have subtypes, augment the constructor type
		if (subtypeEntries.length > 0) {
			lines.push(`${indentStr}interface ${node.name}Subtypes {`);
			for (const entry of subtypeEntries) {
				lines.push(`${indentStr}\t${entry};`);
			}
			lines.push(`${indentStr}}`);
			lines.push('');
		}
	}

	/**
	 * Generate a simple type declaration for a single type
	 */
	generateSingleType(node: TypeNode): string {
		const lines: string[] = [];
		this.generateInstanceInterface(node, lines, 0);
		return lines.join('\n');
	}
}
