'use strict';

import { TypeNode, GeneratedTypes } from './types';
import { TypeGraphImpl } from './graph';

/**
 * TypeScript declaration file generator
 */
export class TypesGenerator {
	constructor(private graph: TypeGraphImpl) {}

	/**
	 * Generate the complete .d.ts file content for module augmentation
	 * This adds nested constructors to mnemonica's instance types
	 */
	generate(): GeneratedTypes {
		const lines: string[] = [];
		const generatedTypes: string[] = [];

		// Header
		lines.push('// Generated by @mnemonica/tactica - DO NOT EDIT');
		lines.push('// This file provides TypeScript types for Mnemonica nested constructors');
		lines.push('');
		lines.push('/* eslint-disable @typescript-eslint/no-empty-object-type */');
		lines.push('/* eslint-disable @typescript-eslint/no-empty-interface */');
		lines.push('');

		// Generate instance type augmentations
		lines.push('// Augmented instance types with nested constructors');
		lines.push('declare module "mnemonica" {');

		// Generate instance interfaces with nested constructors
		for (const root of this.graph.roots.values()) {
			for (const node of this.graph.dfs(root)) {
				const interfaceName = `${node.name}Instance`;
				generatedTypes.push(interfaceName);
				this.generateInstanceInterface(node, lines, 1);
			}
		}

		lines.push('}');

		return {
			content: lines.join('\n'),
			types: generatedTypes,
		};
	}

	/**
	 * Generate a types.ts file with complete instance interfaces
	 * This includes all properties extracted from the constructors
	 */
	generateTypesFile(): GeneratedTypes {
		const lines: string[] = [];
		const generatedTypes: string[] = [];

		// Header
		lines.push('// Generated by @mnemonica/tactica - DO NOT EDIT');
		lines.push('// This file provides complete TypeScript interfaces for Mnemonica types');
		lines.push('');
		lines.push('/* eslint-disable @typescript-eslint/no-empty-object-type */');
		lines.push('/* eslint-disable @typescript-eslint/no-empty-interface */');
		lines.push('');

		// Define a helper type for nested constructors (since IDefinitorInstance is internal)
		lines.push('// Helper type for nested type constructors');
		lines.push('type TypeConstructor<T> = {');
		lines.push('\tnew (...args: unknown[]): T;');
		lines.push('\t(...args: unknown[]): T;');
		lines.push('};');
		lines.push('');

		// Generate complete instance interfaces
		for (const root of this.graph.roots.values()) {
			for (const node of this.graph.dfs(root)) {
				const interfaceName = `${node.name}Instance`;
				generatedTypes.push(interfaceName);
				this.generateCompleteInstanceInterface(node, lines);
			}
		}

		return {
			content: lines.join('\n'),
			types: generatedTypes,
		};
	}

	/**
	 * Generate an instance interface for a type node
	 */
	private generateInstanceInterface(node: TypeNode, lines: string[], indent: number): void {
		const indentStr = '\t'.repeat(indent);
		const interfaceName = `${node.name}Instance`;

		// Build extends clause
		const extendsTypes: string[] = [];
		if (node.parent) {
			extendsTypes.unshift(`${node.parent.name}Instance`);
		}

		const extendsClause = extendsTypes.length > 0
			? ` extends ${extendsTypes.join(', ')}`
			: '';

		lines.push(`${indentStr}interface ${interfaceName}${extendsClause} {`);

		// Add nested constructor properties
		for (const child of node.children.values()) {
			const childInstanceType = `${child.name}Instance`;
			lines.push(`${indentStr}\t${child.name}: {`);
			lines.push(`${indentStr}\t\tnew (...args: unknown[]): ${childInstanceType};`);
			lines.push(`${indentStr}\t\t(...args: unknown[]): ${childInstanceType};`);
			lines.push(`${indentStr}\t};`);
		}

		// For module augmentation, we don't add instance properties
		// because they should already be defined in the source

		lines.push(`${indentStr}}`);
		lines.push('');
	}

	/**
	 * Generate a complete instance interface with all properties
	 * This is for the types.ts file that users import from
	 */
	private generateCompleteInstanceInterface(node: TypeNode, lines: string[]): void {
		const interfaceName = `${node.name}Instance`;

		// Build extends clause
		const extendsTypes: string[] = [];
		if (node.parent) {
			extendsTypes.unshift(`${node.parent.name}Instance`);
		}

		const extendsClause = extendsTypes.length > 0
			? ` extends ${extendsTypes.join(', ')}`
			: '';

		// Export the interface
		lines.push(`export interface ${interfaceName}${extendsClause} {`);

		// Add instance properties extracted from the constructor
		for (const [propName, propInfo] of node.properties.entries()) {
			const optional = propInfo.optional ? '?' : '';
			lines.push(`\t${propName}${optional}: ${propInfo.type};`);
		}

		// Add nested constructor properties
		for (const child of node.children.values()) {
			const childInstanceType = `${child.name}Instance`;
			lines.push(`\t${child.name}: TypeConstructor<${childInstanceType}>;`);
		}

		lines.push('}');
		lines.push('');
	}

	/**
	 * Generate a simple type declaration for a single type
	 */
	generateSingleType(node: TypeNode): string {
		const lines: string[] = [];
		this.generateInstanceInterface(node, lines, 0);
		return lines.join('\n');
	}
}
