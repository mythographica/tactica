'use strict';

import { TypeNode, GeneratedTypes } from './types';
import { TypeGraphImpl } from './graph';

/**
 * TypeScript declaration file generator
 */
export class TypesGenerator {
	constructor(private graph: TypeGraphImpl) {}

	/**
	 * Generate the complete .d.ts file content for module augmentation
	 * This adds nested constructors to mnemonica's instance types
	 */
	generate(): GeneratedTypes {
		const lines: string[] = [];
		const generatedTypes: string[] = [];

		// Header
		lines.push('// Generated by @mnemonica/tactica - DO NOT EDIT');
		lines.push('// This file provides TypeScript types for Mnemonica nested constructors');
		lines.push('');
		lines.push('/* eslint-disable @typescript-eslint/no-empty-object-type */');
		lines.push('/* eslint-disable @typescript-eslint/no-empty-interface */');
		lines.push('');

		// Generate instance type augmentations
		lines.push('// Augmented instance types with nested constructors');
		lines.push('declare module "mnemonica" {');

		// Generate instance interfaces with nested constructors
		for (const root of this.graph.roots.values()) {
			for (const node of this.graph.dfs(root)) {
				const interfaceName = `${node.name}Instance`;
				generatedTypes.push(interfaceName);
				this.generateInstanceInterface(node, lines, 1);
			}
		}

		lines.push('}');

		return {
			content: lines.join('\n'),
			types: generatedTypes,
		};
	}

	/**
		* Generate global augmentation file that augments user classes directly
		* This allows using decorated classes without manual type casting
		*/
	generateGlobalAugmentation(): GeneratedTypes {
		const lines: string[] = [];
		const generatedTypes: string[] = [];

		// Header - must be a module for global augmentation to work
		lines.push('// Generated by @mnemonica/tactica - DO NOT EDIT');
		lines.push('// This file provides automatic type augmentation for decorated classes');
		lines.push('');
		lines.push('/* eslint-disable @typescript-eslint/no-empty-object-type */');
		lines.push('/* eslint-disable @typescript-eslint/no-empty-interface */');
		lines.push('');
		lines.push('export {}; // Make this a module for global augmentation');
		lines.push('');

		// Helper type
		lines.push('// Helper type for nested type constructors');
		lines.push('type TypeConstructor<T> = {');
		lines.push('	new (...args: unknown[]): T;');
		lines.push('	(...args: unknown[]): T;');
		lines.push('};');
		lines.push('');

		// Global augmentation
			lines.push('declare global {');
	
			// Generate instance types for all types
					for (const root of this.graph.roots.values()) {
						for (const node of this.graph.dfs(root)) {
							const instanceName = `${node.name}Instance`;
							generatedTypes.push(instanceName);
							this.generateInstanceType(node, lines, 1);
						}
					}
			
					// Generate class interfaces (add constructors and mnemonica subtypes)
					for (const root of this.graph.roots.values()) {
						for (const node of this.graph.dfs(root)) {
							this.generateClassInterface(node, lines, 1);
						}
					}
	
			lines.push('}');

		return {
			content: lines.join('\n'),
			types: generatedTypes,
		};
	}

	/**
		 * Generate instance type alias (describes what the instance IS)
		 * Uses intersection types for inheritance (types can't extend)
		 */
		private generateInstanceType(node: TypeNode, lines: string[], indent: number): void {
			const indentStr = '\t'.repeat(indent);
			const instanceName = `${node.name}Instance`;
	
			// Build intersection with parent instance
			const parentType = node.parent ? `${node.parent.name}Instance & ` : '';
	
			// Instance is a type describing the data structure
			lines.push(`${indentStr}type ${instanceName} = ${parentType}{`);
	
			// Add instance properties
			for (const [propName, propInfo] of node.properties.entries()) {
				const optional = propInfo.optional ? '?' : '';
				lines.push(`${indentStr}\t${propName}${optional}: ${propInfo.type};`);
			}
	
			// Add nested constructor properties (mnemonica subtypes)
			for (const child of node.children.values()) {
				const childInstanceType = `${child.name}Instance`;
				lines.push(`${indentStr}\t${child.name}: TypeConstructor<${childInstanceType}>;`);
			}
	
			lines.push(`${indentStr}}`);
	
			// Add empty line after each type
			lines.push('');
		}
	
		/**
		 * Generate class interface (describes constructor behavior)
		 * Class extends parent class, contains instance properties and constructors
		 */
		private generateClassInterface(node: TypeNode, lines: string[], indent: number): void {
			const indentStr = '\t'.repeat(indent);
			const instanceName = `${node.name}Instance`;
	
			// Build extends clause - class extends parent class
			const extendsTypes: string[] = [];
			if (node.parent) {
				extendsTypes.push(node.parent.name);
			}
	
			const extendsClause = extendsTypes.length > 0
				? ` extends ${extendsTypes.join(', ')}`
				: '';
	
			// Class is an interface describing the constructor and its instance properties
					lines.push(`${indentStr}interface ${node.name}${extendsClause} {`);
			
					// Add constructor signature for non-root classes (child types need explicit return type)
					// Root classes don't need new() signature - they use the actual class constructor
					if (node.parent) {
						lines.push(`${indentStr}\tnew (): ${instanceName};`);
					}
			
					// Add instance properties (so InstanceType<Order> works correctly)
					for (const [propName, propInfo] of node.properties.entries()) {
						const optional = propInfo.optional ? '?' : '';
						lines.push(`${indentStr}\t${propName}${optional}: ${propInfo.type};`);
					}
	
			// Add subtype constructors to the class
			for (const child of node.children.values()) {
				const childInstanceType = `${child.name}Instance`;
				lines.push(`${indentStr}\t${child.name}: TypeConstructor<${childInstanceType}>;`);
			}
	
			lines.push(`${indentStr}}`);
			lines.push('');
		}
		
			/**
		* Generate a types.ts file with complete instance interfaces
		* This includes all properties extracted from the constructors
		*/
	generateTypesFile(): GeneratedTypes {
		const lines: string[] = [];
		const generatedTypes: string[] = [];

		// Header
		lines.push('// Generated by @mnemonica/tactica - DO NOT EDIT');
		lines.push('// This file provides complete TypeScript interfaces for Mnemonica types');
		lines.push('');
		lines.push('/* eslint-disable @typescript-eslint/no-empty-object-type */');
		lines.push('/* eslint-disable @typescript-eslint/no-empty-interface */');
		lines.push('');

		// Define a helper type for nested constructors (since IDefinitorInstance is internal)
		lines.push('// Helper type for nested type constructors');
		lines.push('type TypeConstructor<T> = {');
		lines.push('\tnew (...args: unknown[]): T;');
		lines.push('\t(...args: unknown[]): T;');
		lines.push('};');
		lines.push('');

		// Generate complete instance interfaces
		for (const root of this.graph.roots.values()) {
			for (const node of this.graph.dfs(root)) {
				const interfaceName = `${node.name}Instance`;
				generatedTypes.push(interfaceName);
				this.generateCompleteInstanceInterface(node, lines);
			}
		}

		return {
			content: lines.join('\n'),
			types: generatedTypes,
		};
	}

	/**
	 * Generate an instance interface for a type node
	 */
	private generateInstanceInterface(node: TypeNode, lines: string[], indent: number): void {
		const indentStr = '\t'.repeat(indent);
		const interfaceName = `${node.name}Instance`;

		// Build extends clause
		const extendsTypes: string[] = [];
		if (node.parent) {
			extendsTypes.unshift(`${node.parent.name}Instance`);
		}

		const extendsClause = extendsTypes.length > 0
			? ` extends ${extendsTypes.join(', ')}`
			: '';

		lines.push(`${indentStr}interface ${interfaceName}${extendsClause} {`);

		// Add nested constructor properties
		for (const child of node.children.values()) {
			const childInstanceType = `${child.name}Instance`;
			lines.push(`${indentStr}\t${child.name}: {`);
			lines.push(`${indentStr}\t\tnew (...args: unknown[]): ${childInstanceType};`);
			lines.push(`${indentStr}\t\t(...args: unknown[]): ${childInstanceType};`);
			lines.push(`${indentStr}\t};`);
		}

		// For module augmentation, we don't add instance properties
		// because they should already be defined in the source

		lines.push(`${indentStr}}`);
		lines.push('');
	}

	/**
	 * Generate a complete instance interface with all properties
	 * This is for the types.ts file that users import from
	 */
	private generateCompleteInstanceInterface(node: TypeNode, lines: string[]): void {
		const interfaceName = `${node.name}Instance`;

		// Build extends clause
		const extendsTypes: string[] = [];
		if (node.parent) {
			extendsTypes.unshift(`${node.parent.name}Instance`);
		}

		const extendsClause = extendsTypes.length > 0
			? ` extends ${extendsTypes.join(', ')}`
			: '';

		// Export the interface
		lines.push(`export interface ${interfaceName}${extendsClause} {`);

		// Add instance properties extracted from the constructor
		for (const [propName, propInfo] of node.properties.entries()) {
			const optional = propInfo.optional ? '?' : '';
			lines.push(`\t${propName}${optional}: ${propInfo.type};`);
		}

		// Add nested constructor properties
		for (const child of node.children.values()) {
			const childInstanceType = `${child.name}Instance`;
			lines.push(`\t${child.name}: TypeConstructor<${childInstanceType}>;`);
		}

		lines.push('}');
		lines.push('');
	}

	/**
	 * Generate a simple type declaration for a single type
	 */
	generateSingleType(node: TypeNode): string {
		const lines: string[] = [];
		this.generateInstanceInterface(node, lines, 0);
		return lines.join('\n');
	}
}
