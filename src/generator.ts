'use strict';

import { TypeNode, GeneratedTypes } from './types';
import { TypeGraphImpl } from './graph';

/**
 * TypeScript declaration file generator
 */
export class TypesGenerator {
	constructor(private graph: TypeGraphImpl) {}

	/**
		* Generate global augmentation file that augments user classes directly
		* This allows using decorated classes without manual type casting
		*
		* All types are placed in the global scope via declare global, which allows
		* them to be accessed from any module without imports. Interfaces declared
		* in the global scope will merge with classes of the same name in user modules.
		*/
	generateGlobalAugmentation(): GeneratedTypes {
		const lines: string[] = [];
		const generatedTypes: string[] = [];

		// Header - make this a module so we can use declare global
		lines.push('// Generated by @mnemonica/tactica - DO NOT EDIT');
		lines.push('// This file provides automatic type augmentation for decorated classes');
		lines.push('');
		lines.push('/* eslint-disable @typescript-eslint/no-empty-object-type */');
		lines.push('/* eslint-disable @typescript-eslint/no-empty-interface */');
		lines.push('');

		// Make this a module so we can use declare global
		lines.push('export {};');
		lines.push('');

		// All types go inside declare global so they are globally accessible
		lines.push('declare global {');
		lines.push('');

		// Helper type - in global scope
		lines.push('	// Helper type for nested type constructors');
		lines.push('	type TypeConstructor<T> = {');
		lines.push('		new (...args: unknown[]): T;');
		lines.push('		(...args: unknown[]): T;');
		lines.push('	};');
		lines.push('');

		// Generate instance types for all types - in global scope
		for (const root of this.graph.roots.values()) {
			for (const node of this.graph.dfs(root)) {
				const instanceName = `${node.name}Instance`;
				generatedTypes.push(instanceName);
				this.generateInstanceType(node, lines, 1);
			}
		}

		// Generate class interfaces - in global scope for declaration merging
		// These interfaces will merge with classes of the same name in user modules
		lines.push('	// Class interfaces for declaration merging');
		lines.push('	// These merge with @decorate() classes to provide proper typing');
		lines.push('');
		for (const root of this.graph.roots.values()) {
			for (const node of this.graph.dfs(root)) {
				this.generateClassInterface(node, lines, 1);
			}
		}

		lines.push('}');

		return {
			content: lines.join('\n'),
			types: generatedTypes,
		};
	}

	/**
		 * Generate instance type alias (describes what the instance IS)
		 * Uses intersection types for inheritance (types can't extend)
		 */
		private generateInstanceType(node: TypeNode, lines: string[], indent: number): void {
			const indentStr = '\t'.repeat(indent);
			const instanceName = `${node.name}Instance`;
	
			// Build intersection with parent instance
			const parentType = node.parent ? `${node.parent.name}Instance & ` : '';
	
			// Instance is a type describing the data structure
			lines.push(`${indentStr}type ${instanceName} = ${parentType}{`);
	
			// Add instance properties
			for (const [propName, propInfo] of node.properties.entries()) {
				const optional = propInfo.optional ? '?' : '';
				lines.push(`${indentStr}\t${propName}${optional}: ${propInfo.type};`);
			}
	
			// Add nested constructor properties (mnemonica subtypes)
			for (const child of node.children.values()) {
				const childInstanceType = `${child.name}Instance`;
				lines.push(`${indentStr}\t${child.name}: TypeConstructor<${childInstanceType}>;`);
			}
	
			lines.push(`${indentStr}}`);
	
			// Add empty line after each type
			lines.push('');
		}
	
		/**
		 * Generate class interface for TypeScript declaration merging
		 * This merges with the actual class to provide proper typing
		 */
		private generateClassInterface(node: TypeNode, lines: string[], indent: number): void {
		const indentStr = '\t'.repeat(indent);

		// Build extends clause
			const extendsTypes: string[] = [];
			if (node.parent) {
				extendsTypes.push(node.parent.name);
			}
	
			const extendsClause = extendsTypes.length > 0
				? ` extends ${extendsTypes.join(', ')}`
				: '';
	
			// Interface with same name as class - TypeScript merges these
			lines.push(`${indentStr}interface ${node.name}${extendsClause} {`);
			
			// Add all instance properties (for type merging)
			for (const [propName, propInfo] of node.properties.entries()) {
				const optional = propInfo.optional ? '?' : '';
				lines.push(`${indentStr}\t${propName}${optional}: ${propInfo.type};`);
			}
	
			// Add subtype constructors (non-optional so they're accessible)
			for (const child of node.children.values()) {
				const childInstanceType = `${child.name}Instance`;
				lines.push(`${indentStr}\t${child.name}: TypeConstructor<${childInstanceType}>;`);
			}
	
			lines.push(`${indentStr}}`);
			lines.push('');
		}
		
			/**
		* Generate a types.ts file with complete instance interfaces
		* This includes all properties extracted from the constructors
		*/
	generateTypesFile(): GeneratedTypes {
		const lines: string[] = [];
		const generatedTypes: string[] = [];

		// Header
		lines.push('// Generated by @mnemonica/tactica - DO NOT EDIT');
		lines.push('// This file provides complete TypeScript interfaces for Mnemonica types');
		lines.push('');
		lines.push('/* eslint-disable @typescript-eslint/no-empty-object-type */');
		lines.push('/* eslint-disable @typescript-eslint/no-empty-interface */');
		lines.push('');

		// Define a helper type for nested constructors (since IDefinitorInstance is internal)
		lines.push('// Helper type for nested type constructors');
		lines.push('type TypeConstructor<T> = {');
		lines.push('\tnew (...args: unknown[]): T;');
		lines.push('\t(...args: unknown[]): T;');
		lines.push('};');
		lines.push('');

		// Generate complete instance interfaces
		for (const root of this.graph.roots.values()) {
			for (const node of this.graph.dfs(root)) {
				const interfaceName = `${node.name}Instance`;
				generatedTypes.push(interfaceName);
				this.generateCompleteInstanceInterface(node, lines);
			}
		}

		return {
			content: lines.join('\n'),
			types: generatedTypes,
		};
	}

	/**
	 * Generate a complete instance type alias with all properties
	 * This is for the types.ts file that users import from
	 */
	private generateCompleteInstanceInterface(node: TypeNode, lines: string[]): void {
		const typeName = `${node.name}Instance`;

		// Build intersection with parent type
		const parentType = node.parent ? `${node.parent.name}Instance & ` : '';

		// Export the type alias
		lines.push(`export type ${typeName} = ${parentType}{`);

		// Add instance properties extracted from the constructor
		for (const [propName, propInfo] of node.properties.entries()) {
			const optional = propInfo.optional ? '?' : '';
			lines.push(`\t${propName}${optional}: ${propInfo.type};`);
		}

		// Add nested constructor properties
		for (const child of node.children.values()) {
			const childInstanceType = `${child.name}Instance`;
			lines.push(`\t${child.name}: TypeConstructor<${childInstanceType}>;`);
		}

		lines.push('}');
		lines.push('');
	}

	/**
	 * Generate a simple type declaration for a single type
	 */
	generateSingleType(node: TypeNode): string {
		const lines: string[] = [];
		this.generateCompleteInstanceInterface(node, lines);
		return lines.join('\n');
	}
}
